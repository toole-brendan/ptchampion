import Foundation\nimport CoreLocation\nimport Combine\n\nclass LocationService: NSObject, LocationServiceProtocol, CLLocationManagerDelegate {\n\n    private let locationManager = CLLocationManager()\n    private var statusContinuation: CheckedContinuation<CLAuthorizationStatus, Never>?\n    private var locationContinuation: CheckedContinuation<CLLocation?, Error>?\n\n    private let authorizationStatusSubject = CurrentValueSubject<CLAuthorizationStatus, Never>(.notDetermined)\n    private let locationSubject = CurrentValueSubject<CLLocation?, Never>(nil)\n    private let errorSubject = PassthroughSubject<Error, Never>()\n\n    var authorizationStatusPublisher: AnyPublisher<CLAuthorizationStatus, Never> {\n        authorizationStatusSubject.eraseToAnyPublisher()\n    }\n    var locationPublisher: AnyPublisher<CLLocation?, Never> {\n        locationSubject.eraseToAnyPublisher()\n    }\n    var errorPublisher: AnyPublisher<Error, Never> {\n        errorSubject.eraseToAnyPublisher()\n    }\n\n    override init() {\n        super.init()\n        locationManager.delegate = self\n        // Set desired accuracy - adjust as needed for battery vs precision\n        locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters // Good balance for local area\n        authorizationStatusSubject.send(locationManager.authorizationStatus)\n    }\n\n    // MARK: - Permissions\n\n    func requestLocationPermission() {\n        let currentStatus = locationManager.authorizationStatus\n        authorizationStatusSubject.send(currentStatus)\n\n        if currentStatus == .notDetermined {\n            print(\"LocationService: Requesting When In Use authorization.\")\n            locationManager.requestWhenInUseAuthorization()\n        } else if currentStatus == .denied || currentStatus == .restricted {\n            print(\"LocationService: Permission previously denied or restricted.\")\n            errorSubject.send(LocationError.permissionDenied)\n        }\n        // If already authorized, do nothing here\n    }\n\n    // MARK: - Location Updates\n\n    func getLastKnownLocation() -> CLLocation? {\n        // Note: locationManager.location might be stale or nil\n        let lastLocation = locationManager.location\n        locationSubject.send(lastLocation)\n        return lastLocation\n    }\n\n    func requestLocationUpdate() {\n        let currentStatus = locationManager.authorizationStatus\n        guard currentStatus == .authorizedWhenInUse || currentStatus == .authorizedAlways else {\n            print(\"LocationService: Cannot request location update, not authorized.\")\n             if currentStatus == .notDetermined {\n                 requestLocationPermission()\n             } else {\n                 errorSubject.send(LocationError.permissionDenied)\n             }\n            return\n        }\n        print(\"LocationService: Requesting location update.\")\n        // Use requestLocation for a single update (more battery efficient than startUpdatingLocation)\n        locationManager.requestLocation()\n    }\n\n    // MARK: - CLLocationManagerDelegate\n\n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        let newStatus = manager.authorizationStatus\n        print(\"LocationService: Authorization status changed to \\(newStatus.rawValue)\")\n        authorizationStatusSubject.send(newStatus)\n        statusContinuation?.resume(returning: newStatus)\n        statusContinuation = nil\n\n        if newStatus == .denied || newStatus == .restricted {\n            errorSubject.send(LocationError.permissionDenied)\n        }\n        // If status becomes authorized, caller might want to trigger a location update\n    }\n\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let latestLocation = locations.last else {\n            print(\"LocationService: Received empty locations array.\")\n            return\n        }\n        print(\"LocationService: Received location update: \\(latestLocation.coordinate)\")\n        locationSubject.send(latestLocation)\n        locationContinuation?.resume(returning: latestLocation)\n        locationContinuation = nil\n    }\n\n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"LocationService: Failed with error: \\(error.localizedDescription)\")\n        let locationError:\ LocationError\n        if let clError = error as? CLError {\n            switch clError.code {\n            case .denied: locationError = .permissionDenied\n            case .locationUnknown: locationError = .locationUnavailable\n            default: locationError = .unknownError(error)\n            }\n        } else {\n            locationError = .unknownError(error)\n        }\n        errorSubject.send(locationError)\n        locationContinuation?.resume(throwing: locationError)\n        locationContinuation = nil\n    }\n\n    deinit {\n        print(\"LocationService deinitialized.\")\n    }\n}\n 