# Design System Implementation Plan


Create a centralized, automated styling system that:
- Uses `design-tokens.json` as the single source of truth-- (PLEASE BE AWARE THAT IOS IS NOT THE PROJECT ROOT -- IOS IS ONE MODULE OF BIGGER PROJECT THAT IS THE ROOT WHERE THE DESIGN TOKENS AND CENTRAL SOURCE OF TRUTH ARE.)
- Automatically propagates token changes throughout the application (INCLUDING TO IOS MODULE, WHICH WE ARE WORKING ON NOW)
- Provides proper module boundaries and clear imports
- Maintains high code quality and compilation performance
- Supports all required components and styling needs

## Implementation Plan

### Phase 1: Setup Swift Package for Design System (1-2 days)

1. **Create Swift Package structure in iOS directory**

   ```bash
   cd /Users/brendantoole/projects/ptchampion/ios
   mkdir -p PTDesignSystem/Sources/{DesignTokens,Components,Resources}
   mkdir -p PTDesignSystem/Tests/{DesignTokensTests,ComponentsTests}
   touch PTDesignSystem/Package.swift
   ```

2. **Initialize the Package.swift file**

   ```swift
   // PTDesignSystem/Package.swift
   // swift-tools-version:5.5
   import PackageDescription

   let package = Package(
       name: "PTDesignSystem",
       platforms: [.iOS(.v14)],
       products: [
           .library(
               name: "PTDesignSystem",
               targets: ["DesignTokens", "Components"]),
       ],
       dependencies: [],
       targets: [
           .target(
               name: "DesignTokens",
               dependencies: [],
               resources: [.process("Resources")]),
           .target(
               name: "Components",
               dependencies: ["DesignTokens"],
               resources: [.process("Resources")]),
           .testTarget(
               name: "DesignTokensTests",
               dependencies: ["DesignTokens"]),
           .testTarget(
               name: "ComponentsTests",
               dependencies: ["Components"]),
       ]
   )
   ```

3. **Create base AppTheme.swift file**

   ```swift
   // PTDesignSystem/Sources/DesignTokens/AppTheme.swift
   import SwiftUI

   // Base AppTheme struct that will be extended by generated code
   public struct AppTheme {
       // Empty base struct - extensions will be added through generated code
   }

   // Shadow type definition for use by GeneratedShadows
   public struct Shadow {
       public let color: Color
       public let radius: CGFloat
       public let x: CGFloat
       public let y: CGFloat
       
       public init(color: Color, radius: CGFloat, x: CGFloat, y: CGFloat) {
           self.color = color
           self.radius = radius
           self.x = x
           self.y = y
       }
   }

   // Extension to apply shadow
   public extension View {
       func withShadow(_ shadow: Shadow) -> some View {
           self.shadow(
               color: shadow.color,
               radius: shadow.radius,
               x: shadow.x,
               y: shadow.y
           )
       }
   }
   ```

4. **Create ThemeManager.swift file**

   ```swift
   // PTDesignSystem/Sources/DesignTokens/ThemeManager.swift
   import SwiftUI

   // ThemeManager for handling dark/light mode
   public final class ThemeManager: ObservableObject {
       public static let shared = ThemeManager()
       
       @Published public var currentColorScheme: ColorScheme = .light
       
       public func toggleDarkMode() {
           currentColorScheme = currentColorScheme == .light ? .dark : .light
       }
   }
   ```

### Phase 2: Modify Style Dictionary Generation Process (1 day)

1. **Update Style Dictionary config to output to the Swift Package**

   Update the `style-dictionary.config.js` file to output directly to the Swift Package:

   ```javascript
   module.exports = {
     source: ["design-tokens.json"],
     platforms: {
       ios: {
         transformGroup: "ios",
         buildPath: "../ios/PTDesignSystem/Sources/DesignTokens/Generated/",
         files: [
           {
             destination: "AppTheme+Generated.swift",
             format: "ios/swift/extension", // Custom format that extends AppTheme
             className: "AppTheme"
           }
         ]
       },
       // Other platforms like web, etc.
     }
   };
   ```

2. **Create a custom formatter for Swift extensions**

   Create a custom formatter in `build-tokens.js` to properly format Swift extensions:

   ```javascript
   const StyleDictionary = require('style-dictionary');

   // Register a custom format for Swift extensions
   StyleDictionary.registerFormat({
     name: 'ios/swift/extension',
     formatter: function({ dictionary, file }) {
       return [
         '// Generated by Style Dictionary',
         'import SwiftUI',
         '',
         '// MARK: - Color Extensions',
         'public extension AppTheme {',
         '  enum GeneratedColors {',
         dictionary.allProperties
           .filter(token => token.type === 'color')
           .map(token => {
             // Format the color token properly
             return `    public static let ${token.name} = Color("${token.name}")`;
           })
           .join('\n'),
         '  }',
         '',
         '  // Add other token type enums...',
         '}'
       ].join('\n')
     }
   });

   // Load the configuration
   const StyleDictionaryExtended = StyleDictionary.extend('./style-dictionary.config.js');

   // Build all platforms
   StyleDictionaryExtended.buildAllPlatforms();
   ```

3. **Create the iOS installation script**

   Update the install script to handle the new package structure:

   ```bash
   #!/bin/bash
   set -e

   # Install iOS generated files into Swift Package
   echo "Installing design tokens for iOS..."

   # Create directories if they don't exist
   mkdir -p ../ios/PTDesignSystem/Sources/DesignTokens/Generated
   mkdir -p ../ios/PTDesignSystem/Sources/Resources/Colors.xcassets

   # Copy files
   cp -r build/ios/AppTheme+Generated.swift ../ios/PTDesignSystem/Sources/DesignTokens/Generated/
   cp -r build/ios/Colors.xcassets/* ../ios/PTDesignSystem/Sources/Resources/Colors.xcassets/

   echo "âœ… iOS design tokens installed successfully!"
   ```

### Phase 3: Integrate Swift Package with Main App (1 day)

1. **Add the local Swift Package to the main app target**

   In Xcode:
   - File > Add Packages...
   - Add Local Package > Select the `PTDesignSystem` folder
   - Add to ptchampion target

   Alternatively, add to the main app's Package.swift:

   ```swift
   dependencies: [
       .package(path: "./PTDesignSystem")
   ],
   ```

2. **Remove hardcoded token values from PTChampionApp.swift**

   Remove the hardcoded AppTheme struct and values from PTChampionApp.swift.

3. **Add imports in required files**

   Update imports in all files that use the design system:

   ```swift
   import PTDesignSystem
   ```

   Or, for more specific imports:

   ```swift
   import DesignTokens
   import Components
   ```

### Phase 4: Create Basic UI Components (2-3 days)

1. **Implement Button component**

   ```swift
   // PTDesignSystem/Sources/Components/Button.swift
   import SwiftUI
   import DesignTokens

   public struct PTButton: View {
       private let title: String
       private let action: () -> Void
       private let style: ButtonStyle
       
       public enum ButtonStyle {
           case primary, secondary, destructive
       }
       
       public init(_ title: String, style: ButtonStyle = .primary, action: @escaping () -> Void) {
           self.title = title
           self.style = style
           self.action = action
       }
       
       public var body: some View {
           Button(action: action) {
               Text(title)
                   .font(AppTheme.GeneratedTypography.buttonText())
                   .foregroundColor(foregroundColor)
                   .padding(.vertical, AppTheme.GeneratedSpacing.buttonVertical)
                   .padding(.horizontal, AppTheme.GeneratedSpacing.buttonHorizontal)
                   .frame(maxWidth: .infinity)
           }
           .background(backgroundColor)
           .cornerRadius(AppTheme.GeneratedRadius.button)
       }
       
       private var backgroundColor: Color {
           switch style {
           case .primary:
               return AppTheme.GeneratedColors.primary
           case .secondary:
               return AppTheme.GeneratedColors.secondary
           case .destructive:
               return AppTheme.GeneratedColors.error
           }
       }
       
       private var foregroundColor: Color {
           switch style {
           case .primary, .destructive:
               return .white
           case .secondary:
               return AppTheme.GeneratedColors.textPrimary
           }
       }
   }
   ```

2. **Implement Card component**

   ```swift
   // PTDesignSystem/Sources/Components/Card.swift
   import SwiftUI
   import DesignTokens

   public struct PTCard<Content: View>: View {
       private let content: Content
       
       public init(@ViewBuilder content: () -> Content) {
           self.content = content()
       }
       
       public var body: some View {
           content
               .padding(AppTheme.GeneratedSpacing.contentPadding)
               .background(AppTheme.GeneratedColors.cardBackground)
               .cornerRadius(AppTheme.GeneratedRadius.card)
               .withShadow(AppTheme.GeneratedShadows.small)
       }
   }
   ```

3. **Create other basic components**

   - Implement TextField, Label, Separator components
   - Create SwiftUI previews for each component

### Phase 5: Testing and Documentation (1-2 days)

1. **Create unit tests**

   ```swift
   // PTDesignSystem/Tests/DesignTokensTests/AppThemeTests.swift
   import XCTest
   @testable import DesignTokens

   final class AppThemeTests: XCTestCase {
       func testColorTokensExist() {
           // Basic verification that colors exist
           XCTAssertNotNil(AppTheme.GeneratedColors.primary)
           XCTAssertNotNil(AppTheme.GeneratedColors.secondary)
           // etc.
       }
       
       func testTypographyTokensExist() {
           // Verify typography sizes
           XCTAssertEqual(AppTheme.GeneratedTypography.heading1, 40)
           // etc.
       }
   }
   ```

2. **Add documentation comments**

   ```swift
   /// A design token-driven button component that automatically applies styling
   /// based on the design system.
   ///
   /// Usage:
   ///
   /// ```swift
   /// PTButton("Sign In", style: .primary) {
   ///    handleSignIn()
   /// }
   /// ```
   public struct PTButton: View { ... }
   ```

3. **Create DocC documentation**

   - Create a documentation catalog
   - Add tutorials and examples
   - Generate DocC documentation

### Phase 6: Migrate Existing UI (3-5 days)

1. **Identify and prioritize views to update**

   Create a spreadsheet or list of all views that need updating, prioritized by:
   - User-facing importance
   - Complexity of updates required
   - Number of references to the styling system

2. **Update high-priority views**

   - Dashboard views
   - Authentication screens
   - Core functionality screens

3. **Update remaining views**

   - Settings, profile views
   - Less frequently used views

4. **Perform visual regression testing**

   - Create snapshots of views before and after the migration
   - Compare to verify visual consistency is maintained

## Timeline

| Phase | Description | Duration | Dependencies |
|-------|-------------|----------|--------------|
| 1 | Swift Package Setup | 1-2 days | None |
| 2 | Style Dictionary Modification | 1 day | Phase 1 |
| 3 | App Integration | 1 day | Phases 1, 2 |
| 4 | UI Components | 2-3 days | Phase 3 |
| 5 | Testing and Documentation | 1-2 days | Phase 4 |
| 6 | Migration | 3-5 days | Phases 3, 4 |
| **Total** | | **9-14 days** | |

## Benefits of This Approach

1. **Single Source of Truth**: All styling decisions come from design-tokens.json
2. **Automated Updates**: Changes to tokens propagate automatically through the build process
3. **Clear Module Boundaries**: The Swift Package structure provides compiler-enforced boundaries
4. **Improved Reusability**: Components and tokens are packaged for reuse
5. **Better Testing**: Isolated testing of design system components
6. **Proper Documentation**: Structured documentation for the design system

## Potential Challenges and Mitigations

| Challenge | Mitigation |
|-----------|------------|
| Initial setup complexity | Front-load the architecture work, provide clear documentation |
| Learning curve for team | Create example usage patterns, pair programming sessions |
| Build process integration | Automate build steps, document manual process until CI is updated |
| Migration effort | Prioritize high-impact views, consider incremental approach |
| Backward compatibility | Maintain support for legacy styling during transition period |

## Future Enhancements

1. **Theme Switching**: Add runtime theme switching capabilities
2. **Component Library**: Expand component library to cover all UI patterns
3. **Animation Tokens**: Add support for standardized animations
4. **Cross-Platform**: Extend to Android and Web with the same token source
5. **Version Management**: Add semantic versioning to the design system package 