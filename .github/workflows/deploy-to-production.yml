name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      deploy_frontend:
        description: 'Deploy frontend'
        type: boolean
        default: true
      deploy_backend:
        description: 'Deploy backend'
        type: boolean
        default: true

env:
  AZURE_RESOURCE_GROUP: ptchampion-rg
  ACR_NAME: ${{ secrets.ACR_NAME }}
  STORAGE_ACCOUNT: ptchampionweb
  FRONTEND_DOMAIN: ptchampion.ai
  BACKEND_APP_NAME: ptchampion-api-westus
  FRONT_DOOR_PROFILE: ptchampion-frontend
  FRONT_DOOR_ENDPOINT: ptchampion

permissions:
  id-token: write
  contents: read

jobs:
  build-frontend:
    name: Build Web Frontend
    if: ${{ inputs.deploy_frontend }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        working-directory: ./web
        run: npm ci

      - name: Build for production
        working-directory: ./web
        run: npm run build

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: web-build
          path: web/dist

  build-backend:
    name: Build and Push Backend
    if: ${{ inputs.deploy_backend }}
    runs-on: ubuntu-latest
    outputs:
      image_name: ${{ env.ACR_NAME }}.azurecr.io/ptchampion-api:${{ github.sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Debug OpenAPI file
        run: |
          echo "Current directory: $(pwd)"
          echo "Files in current directory:"
          ls -la
          echo "OpenAPI file exists: $(test -f openapi.yaml && echo 'YES' || echo 'NO')"
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.1.0

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to Azure Container Registry
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ env.ACR_NAME }}.azurecr.io/ptchampion-api:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy
    needs: [build-frontend, build-backend]
    runs-on: ubuntu-latest
    if: always() && ((!inputs.deploy_backend && inputs.deploy_frontend && needs.build-frontend.result == 'success') || (inputs.deploy_backend && needs.build-backend.result == 'success') || (inputs.deploy_frontend && inputs.deploy_backend && needs.build-frontend.result == 'success' && needs.build-backend.result == 'success'))
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Deploy frontend
      - name: Download web build artifact
        if: ${{ inputs.deploy_frontend && needs.build-frontend.result == 'success' }}
        uses: actions/download-artifact@v4
        with:
          name: web-build
          path: web-build

      - name: Deploy web to Static Website
        if: ${{ inputs.deploy_frontend && needs.build-frontend.result == 'success' }}
        run: |
          # Ensure static website is enabled
          az storage blob service-properties update \
            --account-name ${{ env.STORAGE_ACCOUNT }} \
            --static-website \
            --index-document index.html

          # Upload the web files
          az storage blob upload-batch \
            -s web-build \
            -d '$web' \
            --account-name ${{ env.STORAGE_ACCOUNT }} \
            --overwrite

      # Deploy backend if it was built
      - name: Deploy API to App Service
        if: ${{ inputs.deploy_backend && needs.build-backend.result == 'success' }}
        run: |
          IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/ptchampion-api:${{ github.sha }}"
          echo "Deploying image: $IMAGE_NAME"
          
          # Ensure managed identity is configured
          echo "Ensuring managed identity is assigned..."
          IDENTITY=$(az webapp identity assign \
            --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query principalId -o tsv)
          echo "Managed identity principal ID: $IDENTITY"
          
          # Grant ACR pull permissions
          echo "Granting ACR pull permissions..."
          ACR_ID=$(az acr show --name ${{ env.ACR_NAME }} --query id -o tsv)
          az role assignment create \
            --assignee $IDENTITY \
            --scope $ACR_ID \
            --role AcrPull 2>/dev/null || echo "ACR pull permission already exists"
          
          # Deploy container
          az webapp config container set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.BACKEND_APP_NAME }} \
            --docker-custom-image-name "$IMAGE_NAME" \
            --docker-registry-server-url https://${{ env.ACR_NAME }}.azurecr.io

      # Configure container port & environment variables
      - name: Configure container port & env-vars
        if: ${{ inputs.deploy_backend && needs.build-backend.result == 'success' }}
        run: |
          echo "Configuring app settings..."
          
          # Set critical container configuration
          az webapp config appsettings set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.BACKEND_APP_NAME }} \
            --settings \
              WEBSITES_PORT=8080 \
              PORT=8080 \
              AZURE_KEY_VAULT_URL=https://ptchampion-kv.vault.azure.net/ \
              WEBSITES_CONTAINER_START_TIME_LIMIT=600 \
              DOCKER_ENABLE_CI=true \
              DB_SSL_MODE=require
          
          # Ensure always on is enabled for production
          az webapp config set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.BACKEND_APP_NAME }} \
            --always-on true
          
          # Check database configuration
          echo "Checking database configuration..."
          DB_CONFIG=$(az webapp config appsettings list \
            --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "[?name=='DB_HOST' || name=='DB_PORT' || name=='DB_USER' || name=='DB_NAME' || name=='DB_SSL_MODE' || name=='DATABASE_URL'].{name:name,value:value}" -o json)
          
          echo "Database configuration:"
          echo "$DB_CONFIG" | jq -r '.[] | "\(.name): [REDACTED]"'
          
          # Check for missing critical settings
          MISSING_DB_CONFIG=false
          for var in DB_HOST DB_NAME DB_USER; do
            if ! echo "$DB_CONFIG" | jq -e ".[] | select(.name==\"$var\")" > /dev/null; then
              echo "WARNING: Missing database configuration: $var"
              MISSING_DB_CONFIG=true
            fi
          done
          
          if [ "$MISSING_DB_CONFIG" = "true" ]; then
            echo "WARNING: Database configuration is incomplete. Container may fail to start."
            echo "Consider enabling troubleshooting mode temporarily."
          fi

      # Restart backend app after deployment
      - name: Restart backend app
        if: ${{ inputs.deploy_backend && needs.build-backend.result == 'success' }}
        run: |
          az webapp restart --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
          
      # Add comprehensive container diagnostics
      - name: Check container startup and wait for ready
        if: ${{ inputs.deploy_backend && needs.build-backend.result == 'success' }}
        run: |
          echo "Checking container startup status..."
          
          # Enable application logging
          az webapp log config --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --docker-container-logging filesystem \
            --level verbose || true
          
          # Check deployment status
          echo "Checking deployment status..."
          DEPLOYMENT_STATUS=$(az webapp deployment list --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "[0].status" -o tsv || echo "unknown")
          echo "Deployment status: $DEPLOYMENT_STATUS"
          
          # Wait for container to be ready with proper health checks
          echo "Waiting for container to be ready..."
          MAX_ATTEMPTS=20
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            # Check any endpoint to see if container is responding
            for endpoint in "/" "/api/v1/health" "/health" "/healthz"; do
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 \
                "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net$endpoint" || echo "000")
              
              if [ "$STATUS" != "000" ] && [ "$STATUS" != "503" ]; then
                echo "Endpoint $endpoint returned status: $STATUS"
                if [ "$STATUS" = "200" ] || [ "$STATUS" = "404" ] || [ "$STATUS" = "401" ]; then
                  echo "Container is responding! (endpoint: $endpoint, status: $STATUS)"
                  CONTAINER_READY=true
                  break 2
                fi
              fi
            done
            
            if [ $ATTEMPT -eq 5 ] || [ $ATTEMPT -eq 10 ] || [ $ATTEMPT -eq 15 ]; then
              echo "Container still not ready. Checking logs..."
              
              # Download and check logs
              az webapp log download --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --log-file ./container-startup-logs-attempt-$ATTEMPT.zip || true
              
              # Get diagnostics
              echo "Getting container diagnostics..."
              
              # Check app service configuration
              echo "App Service configuration:"
              az webapp config show --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --query "{httpLoggingEnabled:httpLoggingEnabled,detailedErrorLoggingEnabled:detailedErrorLoggingEnabled,alwaysOn:alwaysOn}" || true
              
              # Get recent log entries
              echo "Recent log entries:"
              az webapp log show --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} || true
              
              # Check if container is even running
              CONTAINER_STATUS=$(az webapp show --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --query "state" -o tsv)
              echo "Container state: $CONTAINER_STATUS"
              
              if [ "$CONTAINER_STATUS" != "Running" ]; then
                echo "Container is not in Running state. Attempting restart..."
                az webapp restart --name ${{ env.BACKEND_APP_NAME }} \
                  --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
              fi
            fi
            
            echo "Waiting 15 seconds before next attempt..."
            sleep 15
          done
          
          if [ "$CONTAINER_READY" != "true" ]; then
            echo "ERROR: Container failed to become ready after $MAX_ATTEMPTS attempts (5 minutes)"
            echo "Downloading final logs for debugging..."
            az webapp log download --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --log-file ./container-startup-logs-final.zip || true
          fi
          
      # Verify deployment status
      - name: Verify deployment
        if: ${{ inputs.deploy_backend && needs.build-backend.result == 'success' }}
        run: |
          echo "Verifying deployment of image with tag: ${{ github.sha }}"
          az webapp config container show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
          
          # Container readiness is now checked in the previous step

      # Only check Front Door API route if backend was deployed
      - name: Check Front Door API route (if needed)
        if: ${{ inputs.deploy_backend && needs.build-backend.result == 'success' }}
        run: |
          # Skip expensive Front Door operations if possible
          echo "Checking if Front Door configuration is needed..."
          
          # Quick check if the API route already exists
          API_ROUTE_CHECK=$(az afd route show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
            --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} \
            --route-name "api-route" \
            --query "name" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$API_ROUTE_CHECK" ]; then
            echo "API route already configured. Skipping Front Door configuration."
            exit 0
          fi
          
          echo "API route not found. Proceeding with configuration..."
          echo "Checking Front Door routing configuration..."
          
          # Get the origin group for the API
          API_ORIGIN_GROUP=$(az afd origin-group list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
            --query "[?contains(name, 'api') || contains(name, 'backend')].name" -o tsv)
          
          if [ -z "$API_ORIGIN_GROUP" ]; then
            echo "ERROR: Could not find API origin group. This should be configured in infrastructure."
            # Skip automatic creation - this should be done via infrastructure as code
            exit 1
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
              --origin-group-name "ptchampion-api-origin-group" \
              --probe-path "/api/v1/health" \
              --probe-protocol Https \
              --probe-interval 30 \
              --probe-request-type GET \
              --sample-size 4 \
              --successful-samples-required 3 \
              --additional-latency-in-milliseconds 50
            
            API_ORIGIN_GROUP="ptchampion-api-origin-group"
          else
            echo "Found API origin group: $API_ORIGIN_GROUP"
          fi
          
          # Get the origin for the API
          API_ORIGIN=$(az afd origin list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
            --origin-group-name "$API_ORIGIN_GROUP" \
            --query "[?contains(name, 'api') || contains(name, 'backend')].name" -o tsv)
          
          if [ -z "$API_ORIGIN" ]; then
            echo "ERROR: Could not find API origin. Creating one..."
            # Create origin if it doesn't exist
            az afd origin create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
              --origin-group-name "$API_ORIGIN_GROUP" \
              --origin-name "ptchampion-api-origin" \
              --host-name "${{ env.BACKEND_APP_NAME }}.azurewebsites.net" \
              --http-port 80 \
              --https-port 443 \
              --priority 1 \
              --weight 1000 \
              --enabled-state Enabled
            
            API_ORIGIN="ptchampion-api-origin"
          else
            echo "Found API origin: $API_ORIGIN"
            
            # Verify origin host is correct
            CURRENT_HOST=$(az afd origin show \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
              --origin-group-name "$API_ORIGIN_GROUP" \
              --origin-name "$API_ORIGIN" \
              --query "hostName" -o tsv)
            
            if [ "$CURRENT_HOST" != "${{ env.BACKEND_APP_NAME }}.azurewebsites.net" ]; then
              echo "Incorrect host name for API origin. Updating from $CURRENT_HOST to ${{ env.BACKEND_APP_NAME }}.azurewebsites.net"
              
              az afd origin update \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
                --origin-group-name "$API_ORIGIN_GROUP" \
                --origin-name "$API_ORIGIN" \
                --host-name "${{ env.BACKEND_APP_NAME }}.azurewebsites.net" \
                --enabled-state Enabled
            fi
          fi
          
          # Check if API route exists
          API_ROUTE=$(az afd route list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
            --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} \
            --query "[?contains(name, 'api')].name" -o tsv)
          
          if [ -z "$API_ROUTE" ]; then
            echo "ERROR: Could not find API route. Creating one..."
            # Create route if it doesn't exist
            az afd route create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
              --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} \
              --route-name "api-route" \
              --origin-group "$API_ORIGIN_GROUP" \
              --forwarding-protocol HttpsOnly \
              --supported-protocols Http Https \
              --patterns-to-match "/api/*" \
              --link-to-default-domain Enabled \
              --enabled-state Enabled
            
            API_ROUTE="api-route"
          else
            echo "Found API route: $API_ROUTE"
            # Route already exists, no need to update every deployment
          fi
          
          echo "Front Door configuration updated."

      # Single optimized cache purge at the end of deployment
      - name: Purge Front Door cache (selective)
        if: ${{ inputs.deploy_frontend || inputs.deploy_backend }}
        run: |
          echo "Purging Front Door cache for deployed components..."
          
          # Prepare paths to purge based on what was deployed
          PURGE_PATHS=""
          
          if [ "${{ inputs.deploy_frontend }}" = "true" ]; then
            PURGE_PATHS="/,/index.html,/assets/*"
          fi
          
          if [ "${{ inputs.deploy_backend }}" = "true" ]; then
            if [ -n "$PURGE_PATHS" ]; then
              PURGE_PATHS="$PURGE_PATHS,/api/*"
            else
              PURGE_PATHS="/api/*"
            fi
          fi
          
          # Only purge if we have paths
          if [ -n "$PURGE_PATHS" ]; then
            echo "Purging paths: $PURGE_PATHS"
            
            # Use --no-wait to make it asynchronous
            az afd endpoint purge \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
              --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} \
              --content-paths $PURGE_PATHS \
              --no-wait || echo "Cache purge submitted in background"
          fi

  # Quick container diagnostic check
  container-diagnostics:
    name: Container Diagnostics
    needs: deploy
    if: ${{ always() && inputs.deploy_backend && needs.deploy.result != 'cancelled' }}
    runs-on: ubuntu-latest
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Enable logging and check container
        run: |
          echo "=== CONTAINER DIAGNOSTICS ==="
          
          # Enable application logging
          echo "Enabling application logging..."
          az webapp log config --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --application-logging filesystem \
            --detailed-error-messages true \
            --failed-request-tracing true \
            --level information \
            --docker-container-logging filesystem
          
          # Wait for logging to take effect
          sleep 10
          
          # Check container status
          echo "Checking container status..."
          CONTAINER_STATE=$(az webapp show --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "state" -o tsv)
          echo "Container state: $CONTAINER_STATE"
          
          # Get recent logs directly
          echo "Attempting to tail logs for 30 seconds..."
          timeout 30 az webapp log tail --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} || true
          
          # Download logs
          echo "Downloading container logs..."
          az webapp log download --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --log-file ./container-diagnostics.zip || true
          
          # Check if any endpoint responds
          echo "Testing all possible endpoints..."
          BASE_URL="https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net"
          
          for endpoint in "/" "/robots.txt" "/api" "/api/v1" "/api/v1/health" "/health" "/healthz" "/.well-known/health"; do
            echo -n "Testing $endpoint: "
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$BASE_URL$endpoint" || echo "000")
            echo "$STATUS"
            
            if [ "$STATUS" != "000" ] && [ "$STATUS" != "503" ]; then
              echo "Found responsive endpoint!"
              RESPONSIVE=true
              break
            fi
          done
          
          # Get Kudu diagnostics
          echo "Checking Kudu diagnostics endpoint..."
          KUDU_URL="https://${{ env.BACKEND_APP_NAME }}.scm.azurewebsites.net/api/logstream"
          echo "Kudu URL: $KUDU_URL"
          
          # Check current deployment
          echo "Current deployment info:"
          az webapp deployment list --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} || true
          
          # Quick database config check
          echo "Database configuration status:"
          DB_CHECK=$(az webapp config appsettings list \
            --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "[?name=='DB_HOST' || name=='DB_USER' || name=='DB_NAME' || name=='DB_PASSWORD' || name=='DATABASE_URL'].name" -o tsv | wc -l)
          
          echo "Found $DB_CHECK database configuration variables"
          
          if [ "$DB_CHECK" -lt 3 ]; then
            echo "⚠️ WARNING: Database configuration appears incomplete!"
            echo "This is likely why the container is failing to start."
            echo ""
            echo "To temporarily bypass database checks, run:"
            echo "az webapp config appsettings set --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --settings IGNORE_DB_CONNECTION_FAILURE=true IGNORE_MIGRATION_FAILURE=true"
          fi
          
          # Upload diagnostics
          if [ -f ./container-diagnostics.zip ]; then
            echo "Container diagnostics saved to container-diagnostics.zip"
          fi
      
      - name: Upload Container Diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: container-diagnostics
          path: ./container-diagnostics.zip
          if-no-files-found: ignore

  health-check:
    name: Post-Deployment Health Checks
    needs: container-diagnostics
    if: ${{ always() && needs.container-diagnostics.result != 'cancelled' }}
    runs-on: ubuntu-latest
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          
      - name: Debug Environment Variables
        run: |
          echo "FRONTEND_DOMAIN: ${{ env.FRONTEND_DOMAIN }}"
          echo "BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}"
          echo "AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "FRONT_DOOR_PROFILE: ${{ env.FRONT_DOOR_PROFILE }}"
          echo "FRONT_DOOR_ENDPOINT: ${{ env.FRONT_DOOR_ENDPOINT }}"
        
      - name: Get App Service Info
        run: |
          echo "Getting App Service information..."
          az webapp show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "{name:name,state:state,hostNames:hostNames,defaultHostName:defaultHostName,httpsOnly:httpsOnly}"
          
          echo "Checking App Service container settings..."
          az webapp config container show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
          
          echo "Checking App Service configuration..."
          az webapp config show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "{httpLoggingEnabled:httpLoggingEnabled,detailedErrorLoggingEnabled:detailedErrorLoggingEnabled,requestTracingEnabled:requestTracingEnabled}"
        
      - name: Get Front Door Configuration
        run: |
          echo "Getting Front Door configuration..."
          az afd endpoint show \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
            --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} \
            --query "{hostName:hostName,enabledState:enabledState}"
          
          echo "Getting Front Door routes..."
          az afd route list \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
            --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} \
            --query "[].{routeName:name,originGroupName:originGroupName,enabledState:enabledState,forwardingProtocol:forwardingProtocol}"
          
          echo "Getting Front Door rule sets..."
          az afd rule-set list \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name ${{ env.FRONT_DOOR_PROFILE }}
          
          echo "Getting Front Door origin groups..."
          az afd origin-group list \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name ${{ env.FRONT_DOOR_PROFILE }}
          
          echo "Getting Front Door origins..."
          for og in $(az afd origin-group list \
                        -g ${{ env.AZURE_RESOURCE_GROUP }} \
                        --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
                        --query '[].name' -o tsv); do
            az afd origin list \
                -g ${{ env.AZURE_RESOURCE_GROUP }} \
                --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
                --origin-group-name "$og" \
                --query "[].{originName:name,hostName:hostName,enabledState:enabledState}"
          done
      
      - name: DNS Debug
        run: |
          echo "Checking DNS resolution..."
          nslookup ${{ env.FRONTEND_DOMAIN }}
          
          echo "Trace route..."
          if command -v traceroute >/dev/null; then
            traceroute ${{ env.FRONTEND_DOMAIN }}
          else
            echo "traceroute not installed; using tracepath instead"
            tracepath ${{ env.FRONTEND_DOMAIN }}
          fi
          
      - name: Check Web App with Detailed Output
        run: |
          WEB_URL="https://${{ env.FRONTEND_DOMAIN }}"
          echo "Testing web app: $WEB_URL"
          
          echo "Checking using curl with verbose output..."
          curl -v -L "$WEB_URL" || echo "Initial curl verbose check failed"
          
          mkdir -p /tmp/health_check_logs
          
          # Reduced retries from 12 to 6 (1 minute instead of 2)
          for i in {1..6}; do
            echo "Attempt $i: Testing $WEB_URL with detailed output..."
            
            # Save complete request/response details
            RESPONSE_CODE=$(curl -v -L -o "/tmp/health_check_logs/web_response_$i.html" -w "%{http_code}\n%{time_total}\n%{size_download}\n%{speed_download}\n%{local_ip}\n%{local_port}\n%{remote_ip}\n%{remote_port}\n%{http_version}\n%{url_effective}" "$WEB_URL" 2>"/tmp/health_check_logs/web_request_$i.log")
            
            # Parse response details
            HTTP_CODE=$(echo "$RESPONSE_CODE" | head -1)
            TIME_TOTAL=$(echo "$RESPONSE_CODE" | head -2 | tail -1)
            SIZE_DOWNLOAD=$(echo "$RESPONSE_CODE" | head -3 | tail -1)
            SPEED_DOWNLOAD=$(echo "$RESPONSE_CODE" | head -4 | tail -1)
            LOCAL_IP=$(echo "$RESPONSE_CODE" | head -5 | tail -1)
            LOCAL_PORT=$(echo "$RESPONSE_CODE" | head -6 | tail -1)
            REMOTE_IP=$(echo "$RESPONSE_CODE" | head -7 | tail -1)
            REMOTE_PORT=$(echo "$RESPONSE_CODE" | head -8 | tail -1)
            HTTP_VERSION=$(echo "$RESPONSE_CODE" | head -9 | tail -1)
            URL_EFFECTIVE=$(echo "$RESPONSE_CODE" | head -10 | tail -1)
            
            echo "HTTP code: $HTTP_CODE"
            echo "Request time: $TIME_TOTAL seconds"
            echo "Response size: $SIZE_DOWNLOAD bytes"
            echo "Download speed: $SPEED_DOWNLOAD bytes/sec"
            echo "Local IP:Port: $LOCAL_IP:$LOCAL_PORT"
            echo "Remote IP:Port: $REMOTE_IP:$REMOTE_PORT"
            echo "HTTP Version: $HTTP_VERSION"
            echo "Effective URL: $URL_EFFECTIVE"
            
            # Check request details
            echo "Request details:"
            cat "/tmp/health_check_logs/web_request_$i.log"
            
            # Check response content
            echo "First 200 bytes of response body:"
            head -c 200 "/tmp/health_check_logs/web_response_$i.html" | xxd -p | fold -w 2 | paste -sd' ' | sed 's/ /\\x/g' | xargs -I {} echo -e "{}"
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Web check passed with 200 OK"
              break
            else
              echo "Attempt $i: Web check returned $HTTP_CODE, waiting 10 seconds..."
              sleep 10
            fi
            
            if [ $i -eq 6 ]; then
              echo "Web check failed after 1 minute of attempts"
              echo "All request logs:"
              for j in {1..6}; do
                if [ -f "/tmp/health_check_logs/web_request_$j.log" ]; then
                  echo "===== REQUEST LOG $j ====="
                  cat "/tmp/health_check_logs/web_request_$j.log"
                  echo ""
                fi
              done
              exit 1
            fi
          done
      
      - name: Simple Backend Health Check
        if: ${{ inputs.deploy_backend }}
        run: |
          echo "=== SIMPLIFIED HEALTH CHECK ==="
          echo "Note: Detailed diagnostics are in the container-diagnostics job"
          
          # Simple check with extended timeout
          BACKEND_URL="https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net"
          MAX_ATTEMPTS=10
          ATTEMPT=0
          SUCCESS=false
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            # Try multiple endpoints
            for endpoint in "/health" "/api/v1/health" "/" "/healthz"; do
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${BACKEND_URL}${endpoint}" || echo "000")
              
              if [ "$STATUS" = "200" ]; then
                echo "✅ Endpoint $endpoint is healthy (status: $STATUS)"
                SUCCESS=true
                break 2
              elif [ "$STATUS" != "000" ] && [ "$STATUS" != "503" ]; then
                echo "⚠️ Endpoint $endpoint returned status: $STATUS"
              fi
            done
            
            if [ "$SUCCESS" != "true" ]; then
              echo "Waiting 30 seconds before retry..."
              sleep 30
            fi
          done
          
          if [ "$SUCCESS" != "true" ]; then
            echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
            echo "Check the container-diagnostics artifact for detailed logs"
            exit 1
          fi
      
      - name: Skip Complex API Health Check
        if: false
        run: |
          # First check if the container is actually running and accessible
          echo "Checking container accessibility..."
          
          # Test root endpoint first to see if container responds at all
          ROOT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/" || echo "000")
          echo "Root endpoint (/) status: $ROOT_STATUS"
          
          if [ "$ROOT_STATUS" = "503" ]; then
            echo "Container is returning 503 - checking container configuration..."
            
            # Check container configuration
            echo "Container settings:"
            az webapp config container show --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
            
            # Check if the image exists in ACR
            echo "Checking if container image exists in ACR..."
            IMAGE_TAG="${{ github.sha }}"
            IMAGE_EXISTS=$(az acr repository show-tags --name ${{ env.ACR_NAME }} \
              --repository ptchampion-api --query "[?@ == '$IMAGE_TAG'] | length(@)" -o tsv || echo "0")
            
            if [ "$IMAGE_EXISTS" = "0" ]; then
              echo "ERROR: Container image with tag $IMAGE_TAG not found in ACR!"
              exit 1
            else
              echo "Container image exists in ACR"
            fi
            
            # Get container instance details
            echo "Getting container instance details..."
            az webapp config show --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --query "{alwaysOn:alwaysOn,use32BitWorkerProcess:use32BitWorkerProcess,linuxFxVersion:linuxFxVersion}" || true
          fi
          
          # Now find which health endpoint works
          echo "Determining which health endpoint works..."
          
          WORKING_ENDPOINT="none"
          
          # Try /api/v1/health
          API_V1_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 -H "Authorization: Bearer empty" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/v1/health")
          if [ "$API_V1_STATUS" = "200" ]; then
            WORKING_ENDPOINT="/api/v1/health"
            echo "Found working endpoint: /api/v1/health"
          fi
          
          # Try /health if the first one failed
          if [ "$WORKING_ENDPOINT" = "none" ]; then
            HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 -H "Authorization: Bearer empty" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/health")
            if [ "$HEALTH_STATUS" = "200" ]; then
              WORKING_ENDPOINT="/health"
              echo "Found working endpoint: /health"
            fi
          fi
          
          # Try /healthz if still no working endpoint
          if [ "$WORKING_ENDPOINT" = "none" ]; then
            HEALTHZ_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 -H "Authorization: Bearer empty" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/healthz")
            if [ "$HEALTHZ_STATUS" = "200" ]; then
              WORKING_ENDPOINT="/healthz"
              echo "Found working endpoint: /healthz"
            fi
          fi
          
          if [ "$WORKING_ENDPOINT" = "none" ]; then
            echo "❌ ERROR: No working health endpoint found. Continuing with default /api/v1/health but expect failure."
            WORKING_ENDPOINT="/api/v1/health"
          fi
          
          echo "Using health endpoint: $WORKING_ENDPOINT"
          
          # Use the working endpoint through Front Door
          API_URL="https://${{ env.FRONTEND_DOMAIN }}$WORKING_ENDPOINT"
          echo "Testing API: $API_URL"
          
          echo "Checking API using curl with verbose output..."
          curl -v -L -H "Authorization: Bearer empty" "$API_URL" || echo "Initial API curl verbose check failed"
          
          # Test direct backend connection first
          echo "Testing direct backend connection..."
          BACKEND_URL="https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net$WORKING_ENDPOINT"
          echo "Direct backend URL: $BACKEND_URL"
          
          DIRECT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 -H "Authorization: Bearer empty" "$BACKEND_URL")
          echo "Direct backend status: $DIRECT_STATUS"
          
          # If backend is not ready, skip expensive Front Door operations
          if [ "$DIRECT_STATUS" != "200" ]; then
            echo "WARNING: Backend is not healthy yet (status: $DIRECT_STATUS)"
            echo "Checking container logs for diagnostics..."
            
            # Get container logs and status
            echo "Getting container diagnostics..."
            
            # Check if container is running
            CONTAINER_STATE=$(az webapp show --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "state" -o tsv)
            echo "Container state: $CONTAINER_STATE"
            
            # Download logs
            az webapp log download --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --log-file ./health-check-logs.zip || true
            
            # Get recent log entries
            echo "Getting recent log entries:"
            az webapp log show --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} || true
            
            # Check deployment slots
            echo "Checking deployment slots:"
            az webapp deployment slot list --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} || true
            
            # Give container more time with periodic checks
            echo "Waiting for container with periodic status checks..."
            for wait_attempt in {1..4}; do
              echo "Extended wait attempt $wait_attempt/4 (waiting 30s)..."
              sleep 30
              
              DIRECT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 -H "Authorization: Bearer empty" "$BACKEND_URL")
              echo "Direct backend status: $DIRECT_STATUS"
              
              if [ "$DIRECT_STATUS" = "200" ]; then
                echo "Backend is now healthy!"
                break
              fi
              
              # On attempt 3, try a restart
              if [ $wait_attempt -eq 3 ] && [ "$DIRECT_STATUS" = "503" ]; then
                echo "Attempting container restart..."
                az webapp restart --name ${{ env.BACKEND_APP_NAME }} \
                  --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
              fi
            done
            
            # Final check
            DIRECT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 -H "Authorization: Bearer empty" "$BACKEND_URL")
            if [ "$DIRECT_STATUS" != "200" ]; then
              echo "ERROR: Backend still not healthy after extended wait and restart"
              echo "Container may have issues starting up. Check the downloaded logs."
              
              # Check if it's a database connection issue
              echo "Checking for database connection issues..."
              DB_CONFIG_CHECK=$(az webapp config appsettings list \
                --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --query "[?name=='DB_HOST' || name=='DB_USER' || name=='DB_NAME' || name=='DATABASE_URL']" -o json)
              
              if [ "$(echo "$DB_CONFIG_CHECK" | jq '. | length')" -lt 3 ]; then
                echo "WARNING: Database configuration appears incomplete!"
                echo "Enabling temporary troubleshooting mode to bypass database checks..."
                
                az webapp config appsettings set \
                  --name ${{ env.BACKEND_APP_NAME }} \
                  --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                  --settings \
                    IGNORE_DB_CONNECTION_FAILURE=true \
                    IGNORE_MIGRATION_FAILURE=true
                
                echo "Restarting with troubleshooting mode..."
                az webapp restart --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
                
                echo "Waiting 60 seconds for restart..."
                sleep 60
                
                # Try one more time
                TROUBLESHOOT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 -H "Authorization: Bearer empty" "$BACKEND_URL")
                if [ "$TROUBLESHOOT_STATUS" = "200" ]; then
                  echo "WARNING: Container is running in troubleshooting mode!"
                  echo "Database connection is being bypassed - this is temporary!"
                  echo "Please fix database configuration and disable troubleshooting flags."
                else
                  echo "ERROR: Container still failing even in troubleshooting mode (status: $TROUBLESHOOT_STATUS)"
                  exit 1
                fi
              else
                exit 1
              fi
            fi
          fi
          
          mkdir -p /tmp/health_check_logs
          
          # If front door routing for API is not set up, try to set it up
          if [ "$WORKING_ENDPOINT" != "/api/v1/health" ]; then
            FRONT_DOOR_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer empty" "$API_URL")
            if [ "$FRONT_DOOR_STATUS" != "200" ]; then
              echo "⚠️ WARNING: Front Door not routing to working endpoint $WORKING_ENDPOINT"
              
              # Try to check/fix Front Door routes
              API_ROUTE=$(az afd route list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} --query "[?contains(name, 'api')].name" -o tsv)
            
              if [ -z "$API_ROUTE" ]; then
                echo "No API route found in Front Door. Creating one..."
                
                # Find or create origin group
                API_ORIGIN_GROUP=$(az afd origin-group list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --query "[?contains(name, 'api')].name" -o tsv)
                
                if [ -z "$API_ORIGIN_GROUP" ]; then
                  echo "Creating API origin group..."
                  az afd origin-group create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --origin-group-name "api-origin-group" --probe-path "$WORKING_ENDPOINT" --probe-protocol Https --probe-interval 30
                  API_ORIGIN_GROUP="api-origin-group"
                  
                  echo "Creating API origin..."
                  az afd origin create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --origin-group-name "$API_ORIGIN_GROUP" --origin-name "api-origin" --host-name "${{ env.BACKEND_APP_NAME }}.azurewebsites.net" --enabled-state Enabled
                fi
                
                echo "Creating API route..."
                az afd route create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} --route-name "api-route" --origin-group "$API_ORIGIN_GROUP" --forwarding-protocol HttpsOnly --patterns-to-match "/api/*" --link-to-default-domain Enabled --enabled-state Enabled
                
                # If working endpoint is not under /api/, create an additional route
                if [[ "$WORKING_ENDPOINT" != /api/* ]]; then
                  echo "Creating additional route for $WORKING_ENDPOINT..."
                  ROUTE_NAME=$(echo "$WORKING_ENDPOINT" | sed 's/\///g')
                  az afd route create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} --route-name "$ROUTE_NAME-route" --origin-group "$API_ORIGIN_GROUP" --forwarding-protocol HttpsOnly --patterns-to-match "$WORKING_ENDPOINT" --link-to-default-domain Enabled --enabled-state Enabled
                fi
                
                echo "Purging Front Door cache..."
                az afd endpoint purge --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} --content-paths "/*"
                
                echo "Waiting 30 seconds for Front Door changes to propagate..."
                sleep 30
              fi
            fi
          fi
          
          # Now try the health check with the working endpoint
          # Reduced retries from 12 to 6 (1 minute instead of 2)
          for i in {1..6}; do
            echo "Attempt $i: Testing API $API_URL with detailed output..."
            
            # Save complete request/response details with reduced timeout and no retries
            RESPONSE_CODE=$(curl -v -L --max-time 10 -H "Authorization: Bearer empty" -o "/tmp/health_check_logs/api_response_$i.json" -w "%{http_code}\n%{time_total}\n%{size_download}\n%{speed_download}\n%{local_ip}\n%{local_port}\n%{remote_ip}\n%{remote_port}\n%{http_version}\n%{url_effective}" "$API_URL" 2>"/tmp/health_check_logs/api_request_$i.log")
            
            # Parse response details
            HTTP_CODE=$(echo "$RESPONSE_CODE" | head -1)
            TIME_TOTAL=$(echo "$RESPONSE_CODE" | head -2 | tail -1)
            SIZE_DOWNLOAD=$(echo "$RESPONSE_CODE" | head -3 | tail -1)
            SPEED_DOWNLOAD=$(echo "$RESPONSE_CODE" | head -4 | tail -1)
            LOCAL_IP=$(echo "$RESPONSE_CODE" | head -5 | tail -1)
            LOCAL_PORT=$(echo "$RESPONSE_CODE" | head -6 | tail -1)
            REMOTE_IP=$(echo "$RESPONSE_CODE" | head -7 | tail -1)
            REMOTE_PORT=$(echo "$RESPONSE_CODE" | head -8 | tail -1)
            HTTP_VERSION=$(echo "$RESPONSE_CODE" | head -9 | tail -1)
            URL_EFFECTIVE=$(echo "$RESPONSE_CODE" | head -10 | tail -1)
            
            echo "HTTP code: $HTTP_CODE"
            echo "Request time: $TIME_TOTAL seconds"
            echo "Response size: $SIZE_DOWNLOAD bytes"
            echo "Download speed: $SPEED_DOWNLOAD bytes/sec"
            echo "Local IP:Port: $LOCAL_IP:$LOCAL_PORT"
            echo "Remote IP:Port: $REMOTE_IP:$REMOTE_PORT"
            echo "HTTP Version: $HTTP_VERSION"
            echo "Effective URL: $URL_EFFECTIVE"
            
            # Check request details
            echo "Request details:"
            cat "/tmp/health_check_logs/api_request_$i.log"
            
            # Check response content
            echo "Response body:"
            if [ -s "/tmp/health_check_logs/api_response_$i.json" ]; then
              cat "/tmp/health_check_logs/api_response_$i.json"
            else
              echo "Empty response body"
            fi
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "API health check passed with 200 OK"
              break
            else
              echo "Attempt $i: API check returned $HTTP_CODE, waiting 10 seconds..."
              
              # Try direct connection to backend on failure
              if [ $i -eq 6 ]; then
                echo "Testing direct backend connection after 6 failed attempts..."
                curl -v -L -H "Authorization: Bearer empty" "$BACKEND_URL" || echo "Direct backend curl check failed"
              fi
              
              sleep 10
            fi
            
            if [ $i -eq 6 ]; then
              echo "API check failed after 1 minute of attempts"
              echo "All API request logs:"
              for j in {1..6}; do
                if [ -f "/tmp/health_check_logs/api_request_$j.log" ]; then
                  echo "===== API REQUEST LOG $j ====="
                  cat "/tmp/health_check_logs/api_request_$j.log"
                  echo ""
                fi
              done
              
              # Check App Service logs as a last resort
              echo "Checking App Service logs..."
              az webapp log download --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --log-file ./app-logs.zip || echo "Could not download App Service logs"
              
              exit 1
            fi
          done

      - name: Check Container Logs
        if: ${{ inputs.deploy_backend }}
        run: |
          echo "Retrieving container logs from App Service..."
          LOG_URL=$(az webapp log download --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --log-file ./container-logs.zip -o tsv 2>/dev/null)
          echo "Log download initiated: $LOG_URL"
      
      - name: Upload Debug Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-check-debug-logs
          path: /tmp/health_check_logs/

      - name: Notify on successful deployment
        if: success()
        run: |
          echo "✅ Successfully deployed PT Champion to production!"
          
          # Add Slack notification if you have a webhook
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"✅ Successfully deployed PT Champion to production!"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }} 

      - name: Check App Service Configuration and Routes
        if: ${{ inputs.deploy_backend }}
        run: |
          # Get detailed app settings (masking secrets)
          echo "Getting App Service settings..."
          az webapp config appsettings list --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} | grep -v -E 'value|connectionString' || echo "Failed to get app settings"
          
          # Check app service logs for any errors during startup
          echo "Checking startup logs..."
          az webapp log deployment show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} || echo "Failed to get deployment logs"
          
          # Check if container is actually running
          echo "Checking container status..."
          az webapp config container show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} || echo "Failed to get container config"
          
          # Check health of webapp
          echo "Getting web app health..."
          az webapp show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "{name:name,state:state,usageState:usageState,enabled:enabled,defaultHostName:defaultHostName,availabilityState:availabilityState}" || echo "Failed to get webapp health"
          
          # Try restarting app one more time
          echo "Attempting to restart app service..."
          az webapp restart --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} || echo "Failed to restart app"
          
          # Wait for app to restart
          echo "Waiting 15 seconds for restart..."
          sleep 15
          
          # Check direct health one more time after restart
          echo "Checking health after restart..."
          BACKEND_URL="https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net$WORKING_ENDPOINT"
          curl -v -L -H "Authorization: Bearer empty" -o "/tmp/health_check_logs/backend_after_restart.json" "$BACKEND_URL" || echo "Health check after restart failed"

      # DIRECT DEBUGGING: Add triage steps directly in the health check
      - name: Emergency API Triage
        if: ${{ inputs.deploy_backend }}
        run: |
          # Create directory for logs
          mkdir -p /tmp/emergency_triage
          
          echo "=== EMERGENCY TRIAGE: Testing all possible health endpoints ==="
          
          # Check direct access to /api/v1/health
          echo "1. Testing direct access to /api/v1/health..."
          DIRECT_API_V1=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer empty" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/v1/health")
          echo "Direct /api/v1/health status: $DIRECT_API_V1"
          
          # Check direct access to /health
          echo "2. Testing direct access to /health..."
          DIRECT_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer empty" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/health")
          echo "Direct /health status: $DIRECT_HEALTH"
          
          # Check direct access to /healthz
          echo "3. Testing direct access to /healthz..."
          DIRECT_HEALTHZ=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer empty" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/healthz")
          echo "Direct /healthz status: $DIRECT_HEALTHZ"
          
          # Check Front Door routing
          echo "4. Testing Front Door access to /api/v1/health..."
          FRONT_DOOR_API=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer empty" "https://${{ env.FRONTEND_DOMAIN }}/api/v1/health")
          echo "Front Door /api/v1/health status: $FRONT_DOOR_API"
          
          # Check Front Door API configuration
          echo "5. Checking Front Door API routes..."
          az afd route list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} --query "[?contains(name, 'api')].{name:name,patternsToMatch:patternsToMatch,originGroup:originGroup}" -o json
          
          # Check if any health endpoint works
          WORKING_ENDPOINT="none"
          if [ "$DIRECT_API_V1" = "200" ]; then
            WORKING_ENDPOINT="/api/v1/health"
          elif [ "$DIRECT_HEALTH" = "200" ]; then
            WORKING_ENDPOINT="/health"
          elif [ "$DIRECT_HEALTHZ" = "200" ]; then
            WORKING_ENDPOINT="/healthz"
          fi
          
          echo "WORKING HEALTH ENDPOINT: $WORKING_ENDPOINT"
          
          # Quick fix based on findings
          if [ "$WORKING_ENDPOINT" != "none" ] && [ "$WORKING_ENDPOINT" != "/api/v1/health" ]; then
            echo "Found working health endpoint at $WORKING_ENDPOINT but workflow expects /api/v1/health"
            
            # Check if there's a Front Door route for API
            API_ROUTE=$(az afd route list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} --query "[?contains(name, 'api')].name" -o tsv)
            
            if [ -n "$API_ROUTE" ]; then
              echo "Found API route in Front Door: $API_ROUTE"
              echo "Retrieving origin group..."
              
              ORIGIN_GROUP=$(az afd route show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --profile-name ${{ env.FRONT_DOOR_PROFILE }} --endpoint-name ${{ env.FRONT_DOOR_ENDPOINT }} --route-name "$API_ROUTE" --query "originGroup" -o tsv)
              
              if [ -n "$ORIGIN_GROUP" ]; then
                echo "Updating health probe path for origin group $ORIGIN_GROUP to $WORKING_ENDPOINT"
                
                az afd origin-group update \
                  --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                  --profile-name ${{ env.FRONT_DOOR_PROFILE }} \
                  --origin-group-name "$ORIGIN_GROUP" \
                  --probe-path "$WORKING_ENDPOINT" \
                  --probe-protocol Https
              fi
            fi
          fi
          
          echo "=== EMERGENCY TRIAGE COMPLETE ==="

  # Add a new job for API triage before the health check
  api-triage:
    name: API Triage
    needs: deploy
    runs-on: ubuntu-latest
    if: ${{ inputs.deploy_backend }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Create logs directory
        run: mkdir -p /tmp/api_triage_logs
      
      - name: Check direct API health endpoint
        run: |
          echo "Testing direct API health endpoint at /api/v1/health..."
          curl -v -H "Authorization: Bearer empty" https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/v1/health > /tmp/api_triage_logs/direct_api_v1_health.log 2>&1
          
          DIRECT_API_V1_STATUS=$(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/direct_api_v1_health.log | tail -1)
          echo "Direct API /api/v1/health status: $DIRECT_API_V1_STATUS"
          
          if [ "$DIRECT_API_V1_STATUS" = "200" ]; then
            echo "✅ Direct API health endpoint is working at /api/v1/health. This confirms Front Door routing issue."
          elif [ "$DIRECT_API_V1_STATUS" = "404" ]; then
            echo "❌ Direct API health endpoint returns 404 at /api/v1/health. The route is missing in the API code."
          else
            echo "⚠️ Direct API health endpoint returned unexpected status: $DIRECT_API_V1_STATUS"
          fi
      
      - name: Check standard health endpoint
        run: |
          echo "Testing standard health endpoint at /health..."
          curl -v -H "Authorization: Bearer empty" https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/health > /tmp/api_triage_logs/direct_health.log 2>&1
          
          DIRECT_HEALTH_STATUS=$(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/direct_health.log | tail -1)
          echo "Direct API /health status: $DIRECT_HEALTH_STATUS"
          
          if [ "$DIRECT_HEALTH_STATUS" = "200" ]; then
            echo "✅ Standard health endpoint is working at /health. Update Front Door probe to use /health instead."
          elif [ "$DIRECT_HEALTH_STATUS" = "404" ]; then
            echo "❌ Standard health endpoint returns 404 at /health."
          else
            echo "⚠️ Standard health endpoint returned unexpected status: $DIRECT_HEALTH_STATUS"
          fi
      
      - name: Check healthz endpoint
        run: |
          echo "Testing healthz endpoint at /healthz..."
          curl -v -H "Authorization: Bearer empty" https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/healthz > /tmp/api_triage_logs/direct_healthz.log 2>&1
          
          DIRECT_HEALTHZ_STATUS=$(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/direct_healthz.log | tail -1)
          echo "Direct API /healthz status: $DIRECT_HEALTHZ_STATUS"
          
          if [ "$DIRECT_HEALTHZ_STATUS" = "200" ]; then
            echo "✅ Healthz endpoint is working at /healthz. Update Front Door probe to use /healthz instead."
          elif [ "$DIRECT_HEALTHZ_STATUS" = "404" ]; then
            echo "❌ Healthz endpoint returns 404 at /healthz."
          else
            echo "⚠️ Healthz endpoint returned unexpected status: $DIRECT_HEALTHZ_STATUS"
          fi
      
      - name: Check Front Door routing to API
        run: |
          echo "Testing Front Door routing to API..."
          curl -v -H "Authorization: Bearer empty" https://${{ env.FRONTEND_DOMAIN }}/api/v1/health > /tmp/api_triage_logs/front_door_api_v1_health.log 2>&1
          
          FRONT_DOOR_STATUS=$(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/front_door_api_v1_health.log | tail -1)
          echo "Front Door API /api/v1/health status: $FRONT_DOOR_STATUS"
          
          if [ "$FRONT_DOOR_STATUS" = "200" ]; then
            echo "✅ Front Door routing is working for /api/v1/health."
          elif [ "$FRONT_DOOR_STATUS" = "404" ]; then
            echo "❌ Front Door returns 404 for /api/v1/health. Check routing rules."
          else
            echo "⚠️ Front Door returned unexpected status: $FRONT_DOOR_STATUS"
          fi
      
      - name: Check logs while making request
        run: |
          echo "Watching logs while making request..."
          # Start log tail in background with timeout
          timeout 15 az webapp log tail --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} > /tmp/api_triage_logs/live_logs.log 2>&1 &
          LOG_PID=$!
          
          # Give log tail time to connect
          sleep 5
          
          # Make request
          echo "Making request to direct API health endpoint..."
          curl -v -H "Authorization: Bearer empty" https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/v1/health > /dev/null 2>&1
          
          # Give time for logs to show up
          sleep 10
          
          # Kill log tail if it's still running
          kill $LOG_PID 2>/dev/null || true
          
          # Check for authentication bypass message
          if grep -q "Skipping authentication for health check endpoint" /tmp/api_triage_logs/live_logs.log; then
            echo "✅ Request bypassed authentication middleware for health check."
            
            # Check if request fell through router
            if grep -q "no handler" /tmp/api_triage_logs/live_logs.log && grep -q "404" /tmp/api_triage_logs/live_logs.log; then
              echo "❌ Request bypassed auth but fell through router (404). The route isn't registered in API code."
            else
              echo "API appears to have handled the request after auth bypass."
            fi
          else
            echo "⚠️ No authentication bypass message found in logs."
          fi
      
      - name: Get Azure health probe configuration
        run: |
          echo "Checking Azure App Service health probe configuration..."
          az webapp show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "{healthCheckPath:healthCheckPath}" -o json
          
          HEALTH_CHECK_PATH=$(az webapp show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "healthCheckPath" -o tsv)
          
          if [ -n "$HEALTH_CHECK_PATH" ]; then
            echo "Current App Service health check path: $HEALTH_CHECK_PATH"
            
            # Test the configured health check path
            echo "Testing configured health check path..."
            curl -v -H "Authorization: Bearer empty" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net$HEALTH_CHECK_PATH" > /tmp/api_triage_logs/configured_health.log 2>&1
            
            CONFIGURED_HEALTH_STATUS=$(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/configured_health.log | tail -1)
            echo "Configured health check status: $CONFIGURED_HEALTH_STATUS"
            
            if [ "$CONFIGURED_HEALTH_STATUS" = "200" ]; then
              echo "✅ Configured health check path is working."
            else
              echo "❌ Configured health check path returned status: $CONFIGURED_HEALTH_STATUS"
            fi
          else
            echo "No health check path configured in App Service."
          fi
      
      - name: Triage summary
        run: |
          echo "===== API TRIAGE SUMMARY ====="
          echo "1. Direct /api/v1/health status: $(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/direct_api_v1_health.log | tail -1 || echo 'unknown')"
          echo "2. Direct /health status: $(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/direct_health.log | tail -1 || echo 'unknown')"
          echo "3. Direct /healthz status: $(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/direct_healthz.log | tail -1 || echo 'unknown')"
          echo "4. Front Door /api/v1/health status: $(grep -oP "< HTTP/[0-9.]+ \K[0-9]+" /tmp/api_triage_logs/front_door_api_v1_health.log | tail -1 || echo 'unknown')"
          
          WORKING_ENDPOINT="none"
          
          if grep -q "< HTTP/[0-9.]\\+ 200" /tmp/api_triage_logs/direct_api_v1_health.log; then
            WORKING_ENDPOINT="/api/v1/health"
          elif grep -q "< HTTP/[0-9.]\\+ 200" /tmp/api_triage_logs/direct_health.log; then
            WORKING_ENDPOINT="/health"
          elif grep -q "< HTTP/[0-9.]\\+ 200" /tmp/api_triage_logs/direct_healthz.log; then
            WORKING_ENDPOINT="/healthz"
          fi
          
          echo "WORKING HEALTH ENDPOINT: $WORKING_ENDPOINT"
          
          if [ "$WORKING_ENDPOINT" = "none" ]; then
            echo "❌ CRITICAL: No working health endpoint found on the API"
            echo "Action needed: Add a health endpoint to the API code"
          elif [ "$WORKING_ENDPOINT" != "/api/v1/health" ]; then
            echo "⚠️ WARNING: Health endpoint exists but at $WORKING_ENDPOINT instead of /api/v1/health"
            echo "Action needed: Either update Front Door to use $WORKING_ENDPOINT or update API to add /api/v1/health endpoint"
          else
            if ! grep -q "< HTTP/[0-9.]\\+ 200" /tmp/api_triage_logs/front_door_api_v1_health.log; then
              echo "⚠️ WARNING: API has working /api/v1/health endpoint but Front Door isn't routing to it"
              echo "Action needed: Fix Front Door routing for /api/*"
            else
              echo "✅ RESOLVED: Both API health endpoint and Front Door routing are working"
            fi
          fi
      
      - name: Upload Triage Logs
        uses: actions/upload-artifact@v4
        with:
          name: api-triage-logs
          path: /tmp/api_triage_logs/