// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: exercise.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const getExercise = `-- name: GetExercise :one
SELECT id, name, description, type FROM exercises
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetExercise(ctx context.Context, id int32) (Exercise, error) {
	row := q.db.QueryRowContext(ctx, getExercise, id)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Type,
	)
	return i, err
}

const getExercisesByType = `-- name: GetExercisesByType :many
SELECT id, name, description, type FROM exercises
WHERE type = $1
ORDER BY name
`

func (q *Queries) GetExercisesByType(ctx context.Context, type_ string) ([]Exercise, error) {
	rows, err := q.db.QueryContext(ctx, getExercisesByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboard = `-- name: GetLeaderboard :many
SELECT 
    u.id AS user_id,
    u.username,
    CONCAT(u.first_name, ' ', u.last_name) as display_name,
    MAX(w.grade) AS max_grade,
    MAX(w.created_at) AS last_attempt_date
FROM 
    workouts w
JOIN 
    users u ON w.user_id = u.id
JOIN
    exercises e ON w.exercise_id = e.id
WHERE 
    e.type = $1
    AND w.grade IS NOT NULL
    AND w.is_public = true
GROUP BY 
    u.id, u.username, u.first_name, u.last_name
ORDER BY 
    max_grade DESC, last_attempt_date ASC
LIMIT 100
`

type GetLeaderboardRow struct {
	UserID          int32       `json:"user_id"`
	Username        string      `json:"username"`
	DisplayName     interface{} `json:"display_name"`
	MaxGrade        interface{} `json:"max_grade"`
	LastAttemptDate interface{} `json:"last_attempt_date"`
}

func (q *Queries) GetLeaderboard(ctx context.Context, type_ string) ([]GetLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeaderboard, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaderboardRow{}
	for rows.Next() {
		var i GetLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.MaxGrade,
			&i.LastAttemptDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWorkoutsByType = `-- name: GetUserWorkoutsByType :many
SELECT w.id, w.user_id, w.exercise_id, w.exercise_type, w.repetitions, w.duration_seconds, w.form_score, w.grade, w.is_public, w.completed_at, w.created_at, w.device_id, w.metadata, w.notes, e.name as exercise_name, e.type as exercise_type
FROM workouts w
JOIN exercises e ON e.id = w.exercise_id
WHERE w.user_id = $1 AND e.type = $2
ORDER BY w.created_at DESC
`

type GetUserWorkoutsByTypeParams struct {
	UserID int32  `json:"user_id"`
	Type   string `json:"type"`
}

type GetUserWorkoutsByTypeRow struct {
	ID              int32                 `json:"id"`
	UserID          int32                 `json:"user_id"`
	ExerciseID      int32                 `json:"exercise_id"`
	ExerciseType    string                `json:"exercise_type"`
	Repetitions     sql.NullInt32         `json:"repetitions"`
	DurationSeconds sql.NullInt32         `json:"duration_seconds"`
	FormScore       sql.NullInt32         `json:"form_score"`
	Grade           int32                 `json:"grade"`
	IsPublic        bool                  `json:"is_public"`
	CompletedAt     time.Time             `json:"completed_at"`
	CreatedAt       time.Time             `json:"created_at"`
	DeviceID        sql.NullString        `json:"device_id"`
	Metadata        pqtype.NullRawMessage `json:"metadata"`
	Notes           sql.NullString        `json:"notes"`
	ExerciseName    string                `json:"exercise_name"`
	ExerciseType_2  string                `json:"exercise_type_2"`
}

func (q *Queries) GetUserWorkoutsByType(ctx context.Context, arg GetUserWorkoutsByTypeParams) ([]GetUserWorkoutsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserWorkoutsByType, arg.UserID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserWorkoutsByTypeRow{}
	for rows.Next() {
		var i GetUserWorkoutsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExerciseID,
			&i.ExerciseType,
			&i.Repetitions,
			&i.DurationSeconds,
			&i.FormScore,
			&i.Grade,
			&i.IsPublic,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.DeviceID,
			&i.Metadata,
			&i.Notes,
			&i.ExerciseName,
			&i.ExerciseType_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWorkoutsHistory = `-- name: GetUserWorkoutsHistory :many
SELECT
    w.id,
    w.user_id,
    w.exercise_id,
    w.repetitions,
    w.duration_seconds,
    w.grade,
    w.form_score,
    w.created_at,
    w.completed_at,
    e.name AS exercise_name,
    e.type AS exercise_type
FROM
    workouts w
JOIN
    exercises e ON w.exercise_id = e.id
WHERE
    w.user_id = $1
ORDER BY
    w.created_at DESC
LIMIT $2
OFFSET $3
`

type GetUserWorkoutsHistoryParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetUserWorkoutsHistoryRow struct {
	ID              int32         `json:"id"`
	UserID          int32         `json:"user_id"`
	ExerciseID      int32         `json:"exercise_id"`
	Repetitions     sql.NullInt32 `json:"repetitions"`
	DurationSeconds sql.NullInt32 `json:"duration_seconds"`
	Grade           int32         `json:"grade"`
	FormScore       sql.NullInt32 `json:"form_score"`
	CreatedAt       time.Time     `json:"created_at"`
	CompletedAt     time.Time     `json:"completed_at"`
	ExerciseName    string        `json:"exercise_name"`
	ExerciseType    string        `json:"exercise_type"`
}

func (q *Queries) GetUserWorkoutsHistory(ctx context.Context, arg GetUserWorkoutsHistoryParams) ([]GetUserWorkoutsHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserWorkoutsHistory, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserWorkoutsHistoryRow{}
	for rows.Next() {
		var i GetUserWorkoutsHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExerciseID,
			&i.Repetitions,
			&i.DurationSeconds,
			&i.Grade,
			&i.FormScore,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.ExerciseName,
			&i.ExerciseType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExercises = `-- name: ListExercises :many
SELECT id, name, description, type FROM exercises
ORDER BY name
`

func (q *Queries) ListExercises(ctx context.Context) ([]Exercise, error) {
	rows, err := q.db.QueryContext(ctx, listExercises)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logWorkout = `-- name: LogWorkout :one
INSERT INTO workouts (
  user_id, 
  exercise_id, 
  exercise_type,
  repetitions, 
  duration_seconds, 
  grade, -- Calculated grade based on performance
  form_score, -- Add form_score from client
  completed_at,
  is_public
)
VALUES (
    $1, -- user_id
    $2, -- exercise_id
    $3, -- exercise_type
    $4, -- repetitions (sqlc.narg)
    $5, -- duration_seconds (sqlc.narg)
    $6, -- grade (calculated)
    $7, -- form_score (sqlc.narg)
    $8, -- completed_at
    $9  -- is_public
)
RETURNING id, user_id, exercise_id, exercise_type, repetitions, duration_seconds, form_score, grade, is_public, completed_at, created_at, device_id, metadata, notes
`

type LogWorkoutParams struct {
	UserID          int32         `json:"user_id"`
	ExerciseID      int32         `json:"exercise_id"`
	ExerciseType    string        `json:"exercise_type"`
	Repetitions     sql.NullInt32 `json:"repetitions"`
	DurationSeconds sql.NullInt32 `json:"duration_seconds"`
	Grade           int32         `json:"grade"`
	FormScore       sql.NullInt32 `json:"form_score"`
	CompletedAt     time.Time     `json:"completed_at"`
	IsPublic        bool          `json:"is_public"`
}

func (q *Queries) LogWorkout(ctx context.Context, arg LogWorkoutParams) (Workout, error) {
	row := q.db.QueryRowContext(ctx, logWorkout,
		arg.UserID,
		arg.ExerciseID,
		arg.ExerciseType,
		arg.Repetitions,
		arg.DurationSeconds,
		arg.Grade,
		arg.FormScore,
		arg.CompletedAt,
		arg.IsPublic,
	)
	var i Workout
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExerciseID,
		&i.ExerciseType,
		&i.Repetitions,
		&i.DurationSeconds,
		&i.FormScore,
		&i.Grade,
		&i.IsPublic,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.DeviceID,
		&i.Metadata,
		&i.Notes,
	)
	return i, err
}
