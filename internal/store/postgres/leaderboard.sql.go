// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: leaderboard.sql

package db

import (
	"context"
	"database/sql"
)

const getLeaderboardByExerciseType = `-- name: GetLeaderboardByExerciseType :many
SELECT 
    u.username,
    u.display_name,
    e.type as exercise_type,
    MAX(ue.grade) as best_grade -- Get the best grade for this exercise type per user
FROM user_exercises ue
JOIN users u ON ue.user_id = u.id
JOIN exercises e ON ue.exercise_id = e.id
WHERE e.type = $1
AND ue.grade IS NOT NULL
GROUP BY u.id, e.type -- Group by user to find their best score for this exercise
ORDER BY best_grade DESC
LIMIT $2
`

type GetLeaderboardByExerciseTypeParams struct {
	Type  string `json:"type"`
	Limit int32  `json:"limit"`
}

type GetLeaderboardByExerciseTypeRow struct {
	Username     string         `json:"username"`
	DisplayName  sql.NullString `json:"display_name"`
	ExerciseType string         `json:"exercise_type"`
	BestGrade    interface{}    `json:"best_grade"`
}

func (q *Queries) GetLeaderboardByExerciseType(ctx context.Context, arg GetLeaderboardByExerciseTypeParams) ([]GetLeaderboardByExerciseTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeaderboardByExerciseType, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaderboardByExerciseTypeRow{}
	for rows.Next() {
		var i GetLeaderboardByExerciseTypeRow
		if err := rows.Scan(
			&i.Username,
			&i.DisplayName,
			&i.ExerciseType,
			&i.BestGrade,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalLeaderboard = `-- name: GetLocalLeaderboard :many

SELECT
    u.id AS user_id,
    u.username,
    u.display_name,
    w.exercise_id,
    -- Aggregate score based on exercise type (e.g., MAX reps or MIN duration)
    -- This example assumes higher repetitions are better.
    -- Adjust aggregation (e.g., MIN(duration_seconds)) and ordering for other types.
    MAX(w.repetitions) AS score
FROM workouts w
JOIN users u ON w.user_id = u.id
WHERE
    -- Filter by specific exercise
    w.exercise_id = $1
    -- Ensure user has a location set
    AND u.last_location IS NOT NULL
    -- Filter users within the specified radius using ST_DWithin
    -- $2 = latitude, $3 = longitude, $4 = radius_meters
    AND ST_DWithin(
        u.last_location,
        -- IMPORTANT: ST_MakePoint expects (longitude, latitude)
        ST_SetSRID(ST_MakePoint($3, $2), 4326)::geography, -- Swapped $2 and $3
        $4
    )
GROUP BY u.id, u.username, u.display_name, w.exercise_id
ORDER BY score DESC
LIMIT 50
`

type GetLocalLeaderboardParams struct {
	ExerciseID    int32       `json:"exercise_id"`
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
}

type GetLocalLeaderboardRow struct {
	UserID      int32          `json:"user_id"`
	Username    string         `json:"username"`
	DisplayName sql.NullString `json:"display_name"`
	ExerciseID  int32          `json:"exercise_id"`
	Score       interface{}    `json:"score"`
}

// Limit the number of results (e.g., top 10, 20)
func (q *Queries) GetLocalLeaderboard(ctx context.Context, arg GetLocalLeaderboardParams) ([]GetLocalLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocalLeaderboard,
		arg.ExerciseID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocalLeaderboardRow{}
	for rows.Next() {
		var i GetLocalLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.ExerciseID,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
