// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: leaderboard.sql

package db

import (
	"context"
	"database/sql"
)

const getGlobalAggregateLeaderboard = `-- name: GetGlobalAggregateLeaderboard :many
WITH user_best_scores AS (
    SELECT 
        u.id as user_id,
        e.type as exercise_type,
        MAX(w.grade) as best_score
    FROM workouts w
    JOIN users u ON w.user_id = u.id
    JOIN exercises e ON w.exercise_id = e.id
    WHERE w.is_public = true
      AND ($2::timestamptz IS NULL OR w.completed_at >= $2::timestamptz)
      AND ($3::timestamptz IS NULL OR w.completed_at < $3::timestamptz)
    GROUP BY u.id, e.type
)
SELECT 
    u.id as user_id,
    u.username,
    CONCAT(u.first_name, ' ', u.last_name) as display_name,
    SUM(ubs.best_score) as score
FROM users u
JOIN user_best_scores ubs ON u.id = ubs.user_id
GROUP BY u.id, u.username, u.first_name, u.last_name
ORDER BY score DESC
LIMIT $1
`

type GetGlobalAggregateLeaderboardParams struct {
	Limit     int32        `json:"limit"`
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetGlobalAggregateLeaderboardRow struct {
	UserID      int32       `json:"user_id"`
	Username    string      `json:"username"`
	DisplayName interface{} `json:"display_name"`
	Score       int64       `json:"score"`
}

func (q *Queries) GetGlobalAggregateLeaderboard(ctx context.Context, arg GetGlobalAggregateLeaderboardParams) ([]GetGlobalAggregateLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalAggregateLeaderboard, arg.Limit, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGlobalAggregateLeaderboardRow{}
	for rows.Next() {
		var i GetGlobalAggregateLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalExerciseLeaderboard = `-- name: GetGlobalExerciseLeaderboard :many

SELECT 
    u.id as user_id,
    u.username,
    CONCAT(u.first_name, ' ', u.last_name) as display_name,
    MAX(w.grade) as score
FROM workouts w
JOIN users u ON w.user_id = u.id
JOIN exercises e ON w.exercise_id = e.id
WHERE e.type = $1
  AND w.is_public = true
  AND ($2::timestamptz IS NULL OR w.completed_at >= $2::timestamptz)
  AND ($3::timestamptz IS NULL OR w.completed_at < $3::timestamptz)
GROUP BY u.id, u.username, u.first_name, u.last_name
ORDER BY score DESC
LIMIT $4
`

type GetGlobalExerciseLeaderboardParams struct {
	Type      string       `json:"type"`
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
	Limit     int32        `json:"limit"`
}

type GetGlobalExerciseLeaderboardRow struct {
	UserID      int32       `json:"user_id"`
	Username    string      `json:"username"`
	DisplayName interface{} `json:"display_name"`
	Score       interface{} `json:"score"`
}

// Apply a reasonable limit
func (q *Queries) GetGlobalExerciseLeaderboard(ctx context.Context, arg GetGlobalExerciseLeaderboardParams) ([]GetGlobalExerciseLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalExerciseLeaderboard,
		arg.Type,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGlobalExerciseLeaderboardRow{}
	for rows.Next() {
		var i GetGlobalExerciseLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboardByExerciseType = `-- name: GetLeaderboardByExerciseType :many
SELECT 
    u.username,
    CONCAT(u.first_name, ' ', u.last_name) as display_name,
    e.type as exercise_type,
    MAX(ue.grade) as best_grade -- Get the best grade for this exercise type per user
FROM user_exercises ue
JOIN users u ON ue.user_id = u.id
JOIN exercises e ON ue.exercise_id = e.id
WHERE e.type = $1
AND ue.grade IS NOT NULL
GROUP BY u.id, e.type -- Group by user to find their best score for this exercise
ORDER BY best_grade DESC
LIMIT $2
`

type GetLeaderboardByExerciseTypeParams struct {
	Type  string `json:"type"`
	Limit int32  `json:"limit"`
}

type GetLeaderboardByExerciseTypeRow struct {
	Username     string      `json:"username"`
	DisplayName  interface{} `json:"display_name"`
	ExerciseType string      `json:"exercise_type"`
	BestGrade    interface{} `json:"best_grade"`
}

func (q *Queries) GetLeaderboardByExerciseType(ctx context.Context, arg GetLeaderboardByExerciseTypeParams) ([]GetLeaderboardByExerciseTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeaderboardByExerciseType, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaderboardByExerciseTypeRow{}
	for rows.Next() {
		var i GetLeaderboardByExerciseTypeRow
		if err := rows.Scan(
			&i.Username,
			&i.DisplayName,
			&i.ExerciseType,
			&i.BestGrade,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalAggregateLeaderboard = `-- name: GetLocalAggregateLeaderboard :many
WITH user_best_scores AS (
    SELECT 
        u.id as user_id,
        e.type as exercise_type,
        MAX(w.grade) as best_score
    FROM workouts w
    JOIN users u ON w.user_id = u.id
    JOIN exercises e ON w.exercise_id = e.id
    WHERE 
        w.is_public = true
        AND ST_DWithin(
            u.last_location::geography,
            ST_MakePoint($1, $2)::geography, -- longitude, then latitude for ST_MakePoint
            $4
        )
        AND ($5::timestamptz IS NULL OR w.completed_at >= $5::timestamptz)
        AND ($6::timestamptz IS NULL OR w.completed_at < $6::timestamptz)
    GROUP BY u.id, e.type
)
SELECT 
    u.id as user_id,
    u.username,
    CONCAT(u.first_name, ' ', u.last_name) as display_name,
    SUM(ubs.best_score) as score,
    ST_Distance(u.last_location::geography, ST_MakePoint($1, $2)::geography) as distance_meters
FROM users u
JOIN user_best_scores ubs ON u.id = ubs.user_id
GROUP BY u.id, u.username, u.first_name, u.last_name, u.last_location
ORDER BY score DESC
LIMIT $3
`

type GetLocalAggregateLeaderboardParams struct {
	Longitude    interface{}  `json:"longitude"`
	Latitude     interface{}  `json:"latitude"`
	Limit        int32        `json:"limit"`
	RadiusMeters interface{}  `json:"radius_meters"`
	StartDate    sql.NullTime `json:"start_date"`
	EndDate      sql.NullTime `json:"end_date"`
}

type GetLocalAggregateLeaderboardRow struct {
	UserID         int32       `json:"user_id"`
	Username       string      `json:"username"`
	DisplayName    interface{} `json:"display_name"`
	Score          int64       `json:"score"`
	DistanceMeters interface{} `json:"distance_meters"`
}

func (q *Queries) GetLocalAggregateLeaderboard(ctx context.Context, arg GetLocalAggregateLeaderboardParams) ([]GetLocalAggregateLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocalAggregateLeaderboard,
		arg.Longitude,
		arg.Latitude,
		arg.Limit,
		arg.RadiusMeters,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocalAggregateLeaderboardRow{}
	for rows.Next() {
		var i GetLocalAggregateLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.Score,
			&i.DistanceMeters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalExerciseLeaderboard = `-- name: GetLocalExerciseLeaderboard :many
SELECT 
    u.id as user_id,
    u.username,
    CONCAT(u.first_name, ' ', u.last_name) as display_name,
    MAX(w.grade) as score,
    ST_Distance(u.last_location::geography, ST_MakePoint($1, $2)::geography) as distance_meters
FROM workouts w
JOIN users u ON w.user_id = u.id
JOIN exercises e ON w.exercise_id = e.id
WHERE 
    e.type = $3 
    AND w.is_public = true
    AND ST_DWithin(
        u.last_location::geography,
        ST_MakePoint($1, $2)::geography, -- longitude, then latitude for ST_MakePoint
        $4 
    )
    AND ($5::timestamptz IS NULL OR w.completed_at >= $5::timestamptz)
    AND ($6::timestamptz IS NULL OR w.completed_at < $6::timestamptz)
GROUP BY u.id, u.username, u.first_name, u.last_name, u.last_location
ORDER BY score DESC
LIMIT $7
`

type GetLocalExerciseLeaderboardParams struct {
	Longitude    interface{}  `json:"longitude"`
	Latitude     interface{}  `json:"latitude"`
	Type         string       `json:"type"`
	RadiusMeters interface{}  `json:"radius_meters"`
	StartDate    sql.NullTime `json:"start_date"`
	EndDate      sql.NullTime `json:"end_date"`
	Limit        int32        `json:"limit"`
}

type GetLocalExerciseLeaderboardRow struct {
	UserID         int32       `json:"user_id"`
	Username       string      `json:"username"`
	DisplayName    interface{} `json:"display_name"`
	Score          interface{} `json:"score"`
	DistanceMeters interface{} `json:"distance_meters"`
}

func (q *Queries) GetLocalExerciseLeaderboard(ctx context.Context, arg GetLocalExerciseLeaderboardParams) ([]GetLocalExerciseLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocalExerciseLeaderboard,
		arg.Longitude,
		arg.Latitude,
		arg.Type,
		arg.RadiusMeters,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocalExerciseLeaderboardRow{}
	for rows.Next() {
		var i GetLocalExerciseLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.Score,
			&i.DistanceMeters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalLeaderboard = `-- name: GetLocalLeaderboard :many

SELECT
    u.id AS user_id,
    u.username,
    CONCAT(u.first_name, ' ', u.last_name) as display_name,
    w.exercise_id,
    -- Aggregate score based on exercise type (e.g., MAX reps or MIN duration)
    -- This example assumes higher repetitions are better.
    -- Adjust aggregation (e.g., MIN(duration_seconds)) and ordering for other types.
    MAX(w.repetitions) AS score
FROM workouts w
JOIN users u ON w.user_id = u.id
WHERE
    -- Filter by specific exercise
    w.exercise_id = $1
    -- Ensure user has a location set
    AND u.last_location IS NOT NULL
    -- Filter users within the specified radius using ST_DWithin
    -- $2 = latitude, $3 = longitude, $4 = radius_meters
    AND ST_DWithin(
        u.last_location,
        -- IMPORTANT: ST_MakePoint expects (longitude, latitude)
        ST_SetSRID(ST_MakePoint($3, $2), 4326)::geography, -- Swapped $2 and $3
        $4
    )
GROUP BY u.id, u.username, u.first_name, u.last_name, w.exercise_id
ORDER BY score DESC
LIMIT 50
`

type GetLocalLeaderboardParams struct {
	ExerciseID    int32       `json:"exercise_id"`
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
}

type GetLocalLeaderboardRow struct {
	UserID      int32       `json:"user_id"`
	Username    string      `json:"username"`
	DisplayName interface{} `json:"display_name"`
	ExerciseID  int32       `json:"exercise_id"`
	Score       interface{} `json:"score"`
}

// Limit the number of results (e.g., top 10, 20)
func (q *Queries) GetLocalLeaderboard(ctx context.Context, arg GetLocalLeaderboardParams) ([]GetLocalLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocalLeaderboard,
		arg.ExerciseID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocalLeaderboardRow{}
	for rows.Next() {
		var i GetLocalLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.ExerciseID,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
