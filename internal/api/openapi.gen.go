// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for UserExerciseSyncStatus.
const (
	Conflict UserExerciseSyncStatus = "conflict"
	Pending  UserExerciseSyncStatus = "pending"
	Synced   UserExerciseSyncStatus = "synced"
)

// Defines values for GetLeaderboardExerciseTypeParamsExerciseType.
const (
	Pullup GetLeaderboardExerciseTypeParamsExerciseType = "pullup"
	Pushup GetLeaderboardExerciseTypeParamsExerciseType = "pushup"
	Run    GetLeaderboardExerciseTypeParamsExerciseType = "run"
	Situp  GetLeaderboardExerciseTypeParamsExerciseType = "situp"
)

// InsertUser Data required to register a new user
type InsertUser struct {
	DisplayName       *string `json:"displayName"`
	Latitude          *string `json:"latitude"`
	Location          *string `json:"location"`
	Longitude         *string `json:"longitude"`
	Password          string  `json:"password"`
	ProfilePictureUrl *string `json:"profilePictureUrl"`
	Username          string  `json:"username"`
}

// LeaderboardResponse Leaderboard entries with best scores
type LeaderboardResponse = []struct {
	BestGrade   int    `json:"best_grade"`
	DisplayName string `json:"display_name"`
	Username    string `json:"username"`
}

// LogExerciseRequest Exercise data to log
type LogExerciseRequest struct {
	Distance   *int    `json:"distance,omitempty"`
	Duration   *int    `json:"duration,omitempty"`
	ExerciseId int     `json:"exercise_id"`
	Notes      *string `json:"notes,omitempty"`
	Reps       *int    `json:"reps,omitempty"`
}

// LogExerciseResponse Logged exercise data with calculated grade
type LogExerciseResponse struct {
	CreatedAt     time.Time `json:"created_at"`
	Distance      *int      `json:"distance,omitempty"`
	ExerciseId    int       `json:"exercise_id"`
	ExerciseName  string    `json:"exercise_name"`
	ExerciseType  string    `json:"exercise_type"`
	Grade         int       `json:"grade"`
	Id            int       `json:"id"`
	Notes         *string   `json:"notes,omitempty"`
	Reps          *int      `json:"reps,omitempty"`
	TimeInSeconds *int      `json:"time_in_seconds,omitempty"`
	UserId        int       `json:"user_id"`
}

// LoginRequest User credentials for login
type LoginRequest struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// LoginResponse Authentication token and user profile
type LoginResponse struct {
	Token string `json:"token"`

	// User User profile information
	User User `json:"user"`
}

// PaginatedExerciseHistoryResponse Paginated exercise history for user
type PaginatedExerciseHistoryResponse struct {
	Items []struct {
		CreatedAt     time.Time `json:"created_at"`
		Distance      *int      `json:"distance,omitempty"`
		ExerciseId    int       `json:"exercise_id"`
		ExerciseName  string    `json:"exercise_name"`
		ExerciseType  string    `json:"exercise_type"`
		Grade         int       `json:"grade"`
		Id            int       `json:"id"`
		Notes         *string   `json:"notes,omitempty"`
		Reps          *int      `json:"reps,omitempty"`
		TimeInSeconds *int      `json:"time_in_seconds,omitempty"`
		UserId        int       `json:"user_id"`
	} `json:"items"`
	Page       int `json:"page"`
	PageSize   int `json:"page_size"`
	TotalCount int `json:"total_count"`
}

// SyncRequest Request payload for synchronizing data
type SyncRequest struct {
	Data *struct {
		Profile *struct {
			DisplayName       *string `json:"displayName"`
			Location          *string `json:"location"`
			ProfilePictureUrl *string `json:"profilePictureUrl"`
		} `json:"profile,omitempty"`
		UserExercises *[]struct {
			Completed     *bool   `json:"completed"`
			DeviceId      *string `json:"deviceId"`
			ExerciseId    int     `json:"exerciseId"`
			FormScore     *int    `json:"formScore"`
			Grade         *int    `json:"grade"`
			Metadata      *string `json:"metadata"`
			Repetitions   *int    `json:"repetitions"`
			SyncStatus    *string `json:"syncStatus"`
			TimeInSeconds *int    `json:"timeInSeconds"`
			UserId        int     `json:"userId"`
		} `json:"userExercises,omitempty"`
	} `json:"data,omitempty"`
	DeviceId          string    `json:"deviceId"`
	LastSyncTimestamp time.Time `json:"lastSyncTimestamp"`
	UserId            int       `json:"userId"`
}

// SyncResponse Response payload after data synchronization
type SyncResponse struct {
	Conflicts *[]UserExercise `json:"conflicts,omitempty"`
	Data      *struct {
		// Profile User profile information
		Profile       *User           `json:"profile,omitempty"`
		UserExercises *[]UserExercise `json:"userExercises,omitempty"`
	} `json:"data,omitempty"`
	Success   bool      `json:"success"`
	Timestamp time.Time `json:"timestamp"`
}

// UpdateUserRequest Fields to update in user profile
type UpdateUserRequest struct {
	DisplayName       *string  `json:"display_name,omitempty"`
	Latitude          *float32 `json:"latitude,omitempty"`
	Location          *string  `json:"location,omitempty"`
	Longitude         *float32 `json:"longitude,omitempty"`
	ProfilePictureUrl *string  `json:"profile_picture_url,omitempty"`
	Username          *string  `json:"username,omitempty"`
}

// User User profile information
type User struct {
	CreatedAt         *string `json:"createdAt"`
	DisplayName       *string `json:"displayName"`
	Id                int     `json:"id"`
	LastSyncedAt      *string `json:"lastSyncedAt"`
	Latitude          *string `json:"latitude"`
	Location          *string `json:"location"`
	Longitude         *string `json:"longitude"`
	ProfilePictureUrl *string `json:"profilePictureUrl"`
	UpdatedAt         *string `json:"updatedAt"`
	Username          string  `json:"username"`
}

// UserExercise Details of a completed or tracked exercise
type UserExercise struct {
	Completed     bool                    `json:"completed"`
	CreatedAt     *string                 `json:"createdAt"`
	DeviceId      *string                 `json:"deviceId"`
	ExerciseId    int                     `json:"exerciseId"`
	FormScore     *int                    `json:"formScore"`
	Grade         *int                    `json:"grade"`
	Id            int                     `json:"id"`
	Metadata      *string                 `json:"metadata"`
	Repetitions   *int                    `json:"repetitions"`
	SyncStatus    *UserExerciseSyncStatus `json:"syncStatus"`
	TimeInSeconds *int                    `json:"timeInSeconds"`
	UpdatedAt     *string                 `json:"updatedAt"`
	UserId        int                     `json:"userId"`
}

// UserExerciseSyncStatus defines model for UserExercise.SyncStatus.
type UserExerciseSyncStatus string

// GetExercisesParams defines parameters for GetExercises.
type GetExercisesParams struct {
	// Page Page number for pagination
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// GetLeaderboardExerciseTypeParams defines parameters for GetLeaderboardExerciseType.
type GetLeaderboardExerciseTypeParams struct {
	// Limit Maximum number of leaderboard entries to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLeaderboardExerciseTypeParamsExerciseType defines parameters for GetLeaderboardExerciseType.
type GetLeaderboardExerciseTypeParamsExerciseType string

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody = LoginRequest

// PostAuthRegisterJSONRequestBody defines body for PostAuthRegister for application/json ContentType.
type PostAuthRegisterJSONRequestBody = InsertUser

// PostExercisesJSONRequestBody defines body for PostExercises for application/json ContentType.
type PostExercisesJSONRequestBody = LogExerciseRequest

// PostSyncJSONRequestBody defines body for PostSync for application/json ContentType.
type PostSyncJSONRequestBody = SyncRequest

// PatchUsersMeJSONRequestBody defines body for PatchUsersMe for application/json ContentType.
type PatchUsersMeJSONRequestBody = UpdateUserRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate a user and get JWT token
	// (POST /auth/login)
	PostAuthLogin(ctx echo.Context) error
	// Register a new user
	// (POST /auth/register)
	PostAuthRegister(ctx echo.Context) error
	// Get exercise history for the current user
	// (GET /exercises)
	GetExercises(ctx echo.Context, params GetExercisesParams) error
	// Log a completed exercise
	// (POST /exercises)
	PostExercises(ctx echo.Context) error
	// Get leaderboard for a specific exercise type
	// (GET /leaderboard/{exerciseType})
	GetLeaderboardExerciseType(ctx echo.Context, exerciseType GetLeaderboardExerciseTypeParamsExerciseType, params GetLeaderboardExerciseTypeParams) error
	// Synchronize client data with the server
	// (POST /sync)
	PostSync(ctx echo.Context) error
	// Update current user profile
	// (PATCH /users/me)
	PatchUsersMe(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostAuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthLogin(ctx)
	return err
}

// PostAuthRegister converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthRegister(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthRegister(ctx)
	return err
}

// GetExercises converts echo context to params.
func (w *ServerInterfaceWrapper) GetExercises(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExercisesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetExercises(ctx, params)
	return err
}

// PostExercises converts echo context to params.
func (w *ServerInterfaceWrapper) PostExercises(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostExercises(ctx)
	return err
}

// GetLeaderboardExerciseType converts echo context to params.
func (w *ServerInterfaceWrapper) GetLeaderboardExerciseType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "exerciseType" -------------
	var exerciseType GetLeaderboardExerciseTypeParamsExerciseType

	err = runtime.BindStyledParameterWithLocation("simple", false, "exerciseType", runtime.ParamLocationPath, ctx.Param("exerciseType"), &exerciseType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exerciseType: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLeaderboardExerciseTypeParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLeaderboardExerciseType(ctx, exerciseType, params)
	return err
}

// PostSync converts echo context to params.
func (w *ServerInterfaceWrapper) PostSync(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSync(ctx)
	return err
}

// PatchUsersMe converts echo context to params.
func (w *ServerInterfaceWrapper) PatchUsersMe(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchUsersMe(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/auth/login", wrapper.PostAuthLogin)
	router.POST(baseURL+"/auth/register", wrapper.PostAuthRegister)
	router.GET(baseURL+"/exercises", wrapper.GetExercises)
	router.POST(baseURL+"/exercises", wrapper.PostExercises)
	router.GET(baseURL+"/leaderboard/:exerciseType", wrapper.GetLeaderboardExerciseType)
	router.POST(baseURL+"/sync", wrapper.PostSync)
	router.PATCH(baseURL+"/users/me", wrapper.PatchUsersMe)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/QGfi1LOH8755m7znwAAAP//ItrYbEgrAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
