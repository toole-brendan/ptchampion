const StyleDictionary = require('style-dictionary');
const fs = require('fs');
const path = require('path');

// Helper function to convert hex to RGB (same as original)
function hexToRgb(hex) {
  // Remove # if present
  hex = hex.replace('#', '');
  
  // Convert 3-digit hex to 6-digit
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  
  // Parse hex values
  try {
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;
    
    // Validate values
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      console.error(`Invalid hex color: #${hex}`);
      return { r: 0.957, g: 0.945, b: 0.902 }; // Default cream color
    }
    
    return { r, g, b };
  } catch (error) {
    console.error(`Error parsing hex color #${hex}: ${error.message}`);
    return { r: 0.957, g: 0.945, b: 0.902 }; // Default cream color
  }
}

// Helper function to parse UIColor format (same as original)
function parseUIColor(colorString) {
  // Extract RGB values from [UIColor colorWithRed:0.957f green:0.945f blue:0.902f alpha:1.000f]
  const regex = /colorWithRed:([\d\.]+)f\s+green:([\d\.]+)f\s+blue:([\d\.]+)f\s+alpha:([\d\.]+)f/;
  const match = colorString.match(regex);
  
  if (match) {
    return {
      r: parseFloat(match[1]),
      g: parseFloat(match[2]),
      b: parseFloat(match[3]),
      a: parseFloat(match[4])
    };
  }
  
  return { r: 0, g: 0, b: 0, a: 1 };
}

// Register a format for iOS Swift color extension
StyleDictionary.registerFormat({
  name: 'ios/swift/extension',
  formatter: function({ dictionary, platform }) {
    // Get all tokens by categories
    const colorBaseTokens = dictionary.allTokens.filter(token => token.path[0] === 'colors' && token.path[1] === 'base');
    const colorSemanticTokens = dictionary.allTokens.filter(token => token.path[0] === 'colors' && token.path[1] === 'semantic');
    const typographySizeTokens = dictionary.allTokens.filter(token => token.path[0] === 'typography' && token.path[1] === 'size');
    const typographyFamilyTokens = dictionary.allTokens.filter(token => token.path[0] === 'typography' && token.path[1] === 'family');
    const spacingTokens = dictionary.allTokens.filter(token => token.path[0] === 'spacing');
    const radiusTokens = dictionary.allTokens.filter(token => token.path[0] === 'radius');
    const shadowTokens = dictionary.allTokens.filter(token => token.path[0] === 'shadow');
    const borderWidthTokens = dictionary.allTokens.filter(token => token.path[0] === 'border-width');
    
    let output = `// Generated by Style Dictionary\nimport SwiftUI\n\npublic extension AppTheme {\n`;
    
    // COLORS
    output += `  enum GeneratedColors {\n`;
    
    // Base colors
    colorBaseTokens.forEach(token => {
      const colorName = token.path[token.path.length - 1];
      // Convert kebab-case to camelCase
      const swiftName = colorName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      // PascalCase for Color asset name
      const assetName = colorName.charAt(0).toUpperCase() + colorName.slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      output += `    public static let ${swiftName} = Color("${assetName}")\n`;
    });
    
    // Semantic colors
    output += '\n    // Semantic colors\n';
    colorSemanticTokens.forEach(token => {
      let colorName;
      // Handle text subgroup specially
      if (token.path.includes('text')) {
        colorName = `text${token.path[token.path.length - 1].charAt(0).toUpperCase()}${token.path[token.path.length - 1].slice(1)}`;
      } else {
        colorName = token.path[token.path.length - 1].replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      }
      
      // PascalCase for Color asset name
      let assetName;
      if (token.path.includes('text')) {
        assetName = `Text${token.path[token.path.length - 1].charAt(0).toUpperCase()}${token.path[token.path.length - 1].slice(1)}`;
      } else {
        assetName = token.path[token.path.length - 1].charAt(0).toUpperCase() + 
                  token.path[token.path.length - 1].slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      }
      
      output += `    public static let ${colorName} = Color("${assetName}")\n`;
    });
    
    output += `  }\n\n`;
    
    // TYPOGRAPHY
    output += `  enum GeneratedTypography {\n`;
    
    // Font sizes
    typographySizeTokens.forEach(token => {
      const sizeName = token.path[token.path.length - 1];
      const swiftName = sizeName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      output += `    public static let ${swiftName}: CGFloat = ${token.value}\n`;
    });
    
    output += '\n';
    
    // Font families
    typographyFamilyTokens.forEach(token => {
      const familyName = token.path[token.path.length - 1];
      const swiftName = familyName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      
      output += `    public static func ${swiftName}(size: CGFloat? = nil) -> Font {\n`;
      output += `      return Font.custom("${token.value}", size: size ?? body, relativeTo: .body)\n`;
      output += `    }\n\n`;
    });
    
    output += `  }\n\n`;
    
    // RADIUS
    output += `  enum GeneratedRadius {\n`;
    
    radiusTokens.forEach(token => {
      const radiusName = token.path[token.path.length - 1];
      const swiftName = radiusName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      output += `    public static let ${swiftName}: CGFloat = ${token.value}\n`;
    });
    
    output += `  }\n\n`;
    
    // SPACING
    output += `  enum GeneratedSpacing {\n`;
    
    spacingTokens.forEach(token => {
      const spacingName = token.path[token.path.length - 1];
      const swiftName = spacingName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      output += `    public static let ${swiftName}: CGFloat = ${token.value}\n`;
    });
    
    output += `  }\n\n`;
    
    // SHADOWS
    output += `  enum GeneratedShadows {\n`;
    
    // Group shadows by their parent name
    const shadowGroups = {};
    shadowTokens.forEach(token => {
      const shadowParent = token.path[1]; // Get the shadow name (small, medium, large)
      const shadowProperty = token.path[2]; // Get the property (color, radius, x, y)
      
      if (!shadowGroups[shadowParent]) {
        shadowGroups[shadowParent] = {};
      }
      
      shadowGroups[shadowParent][shadowProperty] = token.value;
    });
    
    // Output each shadow
    Object.entries(shadowGroups).forEach(([shadowName, properties]) => {
      const swiftName = shadowName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      
      output += `    public static let ${swiftName} = Shadow(\n`;
      output += `      color: Color.black.opacity(${properties.color.match(/rgba\(0,\s*0,\s*0,\s*([\d\.]+)/)[1] || '0.1'}),\n`;
      output += `      radius: ${properties.radius},\n`;
      output += `      x: ${properties.x},\n`;
      output += `      y: ${properties.y}\n`;
      output += `    )\n\n`;
    });
    
    output += `  }\n\n`;
    
    // BORDER WIDTHS
    output += `  enum GeneratedBorderWidth {\n`;
    
    borderWidthTokens.forEach(token => {
      const borderName = token.path[token.path.length - 1];
      const swiftName = borderName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      output += `    public static let ${swiftName}: CGFloat = ${token.value}\n`;
    });
    
    output += `  }\n`;
    output += `}\n`;
    
    return output;
  }
});

// Custom action to create iOS color assets
StyleDictionary.registerAction({
  name: 'ios/create_colorsets',
  do: (dictionary, platform) => {
    // Get all color tokens
    const baseColors = dictionary.allTokens.filter(token => 
      token.path[0] === 'colors' && token.path[1] === 'base'
    );
    
    const semanticColors = dictionary.allTokens.filter(token => 
      token.path[0] === 'colors' && token.path[1] === 'semantic'
    );
    
    const darkColors = dictionary.allTokens.filter(token => 
      token.path[0] === 'colors' && token.path[1] === 'dark'
    );
    
    // Create assets directory - UPDATED PATH
    const assetsDir = path.join(__dirname, '../ios/PTDesignSystem/Sources/DesignTokens/Resources/Colors.xcassets');
    if (!fs.existsSync(assetsDir)) {
      fs.mkdirSync(assetsDir, { recursive: true });
    }
    
    // Create main Contents.json
    const contentsJson = {
      info: {
        author: 'style-dictionary',
        version: 1
      }
    };
    
    fs.writeFileSync(
      path.join(assetsDir, 'Contents.json'),
      JSON.stringify(contentsJson, null, 2)
    );
    
    // Create color sets for base colors
    baseColors.forEach(token => {
      const colorName = token.path[token.path.length - 1];
      const capitalizedName = colorName.charAt(0).toUpperCase() + 
                             colorName.slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      
      // Create color set directory
      const colorSetDir = path.join(assetsDir, `${capitalizedName}.colorset`);
      if (!fs.existsSync(colorSetDir)) {
        fs.mkdirSync(colorSetDir, { recursive: true });
      }
      
      // Find dark mode variant if exists
      let darkValue = token.value;
      
      // Look for a matching dark mode color
      const darkToken = darkColors.find(dt => {
        return dt.path[dt.path.length - 1] === colorName;
      });
      
      if (darkToken) {
        darkValue = darkToken.value;
      }
      
      // Parse color values
      let lightRgb = { r: 0, g: 0, b: 0, a: 1 };
      let darkRgb = { r: 0, g: 0, b: 0, a: 1 };
      
      // Parse colors based on format
      if (token.value.startsWith('#')) {
        lightRgb = hexToRgb(token.value);
      } else if (token.value.includes('UIColor')) {
        lightRgb = parseUIColor(token.value);
      }
      
      if (darkValue.startsWith('#')) {
        darkRgb = hexToRgb(darkValue);
      } else if (darkValue.includes('UIColor')) {
        darkRgb = parseUIColor(darkValue);
      }
      
      // Create Contents.json for the color set
      const colorContents = {
        colors: [
          {
            idiom: 'universal',
            color: {
              'color-space': 'srgb',
              components: {
                red: lightRgb.r.toFixed(3),
                green: lightRgb.g.toFixed(3),
                blue: lightRgb.b.toFixed(3),
                alpha: '1.000'
              }
            }
          },
          {
            idiom: 'universal',
            appearances: [
              {
                appearance: 'luminosity',
                value: 'dark'
              }
            ],
            color: {
              'color-space': 'srgb',
              components: {
                red: darkRgb.r.toFixed(3),
                green: darkRgb.g.toFixed(3),
                blue: darkRgb.b.toFixed(3),
                alpha: '1.000'
              }
            }
          }
        ],
        info: {
          author: 'style-dictionary',
          version: 1
        }
      };
      
      fs.writeFileSync(
        path.join(colorSetDir, 'Contents.json'),
        JSON.stringify(colorContents, null, 2)
      );
    });
    
    // Process semantic colors
    semanticColors.forEach(token => {
      let colorName;
      let colorValue;
      
      // Handle text subgroup specially
      if (token.path.includes('text')) {
        colorName = `Text${token.path[token.path.length - 1].charAt(0).toUpperCase()}${token.path[token.path.length - 1].slice(1)}`;
      } else {
        colorName = token.path[token.path.length - 1].charAt(0).toUpperCase() + 
                   token.path[token.path.length - 1].slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      }
      
      // Create color set directory
      const colorSetDir = path.join(assetsDir, `${colorName}.colorset`);
      if (!fs.existsSync(colorSetDir)) {
        fs.mkdirSync(colorSetDir, { recursive: true });
      }
      
      // Resolve the reference to base color
      colorValue = token.value;
      let alpha = token.alpha || 1.0;
      
      // If this references another color, resolve it
      if (colorValue.startsWith('{') && colorValue.endsWith('}')) {
        const referencePath = colorValue
          .substring(1, colorValue.length - 1)
          .split('.')
          .slice(0, -1); // Remove '.value' at the end
          
        const referencedToken = dictionary.tokens[referencePath[0]];
        if (referencedToken) {
          let current = referencedToken;
          for (let i = 1; i < referencePath.length; i++) {
            current = current[referencePath[i]];
            if (!current) break;
          }
          
          if (current && current.value) {
            colorValue = current.value;
          }
        }
      }
      
      // Find dark mode variant if possible
      let darkValue = colorValue;
      const darkTokenName = token.path[token.path.length - 1];
      const darkToken = darkColors.find(dt => dt.path[dt.path.length - 1] === darkTokenName);
      
      if (darkToken) {
        darkValue = darkToken.value;
        // If dark value is a reference, resolve it
        if (darkValue.startsWith('{') && darkValue.endsWith('}')) {
          const darkReferencePath = darkValue
            .substring(1, darkValue.length - 1)
            .split('.')
            .slice(0, -1); // Remove '.value' at the end
            
          const darkReferencedToken = dictionary.tokens[darkReferencePath[0]];
          if (darkReferencedToken) {
            let current = darkReferencedToken;
            for (let i = 1; i < darkReferencePath.length; i++) {
              current = current[darkReferencePath[i]];
              if (!current) break;
            }
            
            if (current && current.value) {
              darkValue = current.value;
            }
          }
        }
      }
      
      // Parse color values
      let lightRgb = { r: 0, g: 0, b: 0, a: alpha };
      let darkRgb = { r: 0, g: 0, b: 0, a: alpha };
      
      // Parse colors based on format
      if (colorValue.startsWith('#')) {
        lightRgb = hexToRgb(colorValue);
        lightRgb.a = alpha;
      } else if (colorValue.includes('UIColor')) {
        lightRgb = parseUIColor(colorValue);
        lightRgb.a = alpha;
      }
      
      if (darkValue.startsWith('#')) {
        darkRgb = hexToRgb(darkValue);
        darkRgb.a = alpha;
      } else if (darkValue.includes('UIColor')) {
        darkRgb = parseUIColor(darkValue);
        darkRgb.a = alpha;
      }
      
      // Create Contents.json for the color set
      const colorContents = {
        colors: [
          {
            idiom: 'universal',
            color: {
              'color-space': 'srgb',
              components: {
                red: lightRgb.r.toFixed(3),
                green: lightRgb.g.toFixed(3),
                blue: lightRgb.b.toFixed(3),
                alpha: lightRgb.a.toFixed(3)
              }
            }
          },
          {
            idiom: 'universal',
            appearances: [
              {
                appearance: 'luminosity',
                value: 'dark'
              }
            ],
            color: {
              'color-space': 'srgb',
              components: {
                red: darkRgb.r.toFixed(3),
                green: darkRgb.g.toFixed(3),
                blue: darkRgb.b.toFixed(3),
                alpha: darkRgb.a.toFixed(3)
              }
            }
          }
        ],
        info: {
          author: 'style-dictionary',
          version: 1
        }
      };
      
      fs.writeFileSync(
        path.join(colorSetDir, 'Contents.json'),
        JSON.stringify(colorContents, null, 2)
      );
    });
  },
  undo: () => {
    // Optional: Clean up generated files
  }
});

// Basic config - UPDATED PATHS
module.exports = {
  source: ['design-tokens.json'],
  platforms: {
    ios: {
      transformGroup: 'ios',
      buildPath: '../ios/PTDesignSystem/Sources/DesignTokens/Generated/',
      files: [
        {
          destination: 'AppTheme+Generated.swift',
          format: 'ios/swift/extension',
          className: 'AppTheme'
        }
      ],
      actions: ['ios/create_colorsets']
    },
    css: {
      transformGroup: 'css',
      buildPath: 'build/web/',
      files: [
        {
          destination: 'variables.css',
          format: 'css/variables'
        }
      ]
    },
    json: {
      transformGroup: 'js',
      buildPath: 'build/json/',
      files: [
        {
          destination: 'tokens.json',
          format: 'json/flat'
        }
      ]
    }
  }
}; 