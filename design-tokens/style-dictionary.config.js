/*  style-dictionary.config.js  —  final cleaned-up version  */
const StyleDictionary = require('style-dictionary');
const fs   = require('fs');
const path = require('path');

/* --- helpers ----------------------------------------------------------- */
const hexToRgb = hex => {
  hex = hex.replace('#','');
  if (hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  const [r,g,b] = [0,2,4].map(i => parseInt(hex.slice(i,i+2),16)/255 || 0);
  return { r, g, b };
};

const parseUIColor = str => {
  const m = str.match(/Red:([\d.]+)f.*green:([\d.]+)f.*blue:([\d.]+)f.*alpha:([\d.]+)f/);
  return m ? { r:+m[1], g:+m[2], b:+m[3], a:+m[4] } : { r:0, g:0, b:0, a:1 };
};

/* --- Swift formatter --------------------------------------------------- */
StyleDictionary.registerFormat({
  name: 'ios/swift/extension',
  formatter: ({dictionary}) => {

    const camel  = s => s.replace(/-([a-z])/g, (_,g)=>g.toUpperCase());
    const pascal = s => camel(s).replace(/^\w/, c=>c.toUpperCase());

    const lines = [];
    lines.push('// Generated by Style Dictionary');
    lines.push('import SwiftUI\n');
    lines.push('public extension AppTheme {');

    /* ---------- Colours ------------ */
    lines.push('  enum GeneratedColors {');

    /* base */
    dictionary.allTokens
      .filter(t => t.path[0]==='color' && t.path[1]==='base')
      .forEach(t =>
        lines.push(`    public static let ${camel(t.path.at(-1))} = Color("${pascal(t.path.at(-1))}", bundle: .module)`));

    /* semantic */
    lines.push('\n    // Semantic colours');
    dictionary.allTokens
      .filter(t => t.path[0]==='color' && t.path[1]==='semantic')
      .forEach(t=>{
        const isText = t.path.includes('text');
        const name   = isText ? `text${pascal(t.path.at(-1))}` : camel(t.path.at(-1));
        const asset  = isText ? `Text${pascal(t.path.at(-1))}` : pascal(t.path.at(-1));
        lines.push(`    public static let ${name} = Color("${asset}", bundle: .module)`);
      });

    lines.push('  }\n');

    /* ---------- Typography --------- */
    lines.push('  enum GeneratedTypography {');

    // sizes (numeric – no NaN ever)
    dictionary.allTokens
      .filter(t=>t.type==='fontSize')
      .forEach(t=>{
        // t.original.value is still the plain number, so we stay immune to any
        // size/CGFloat or future transforms that wrap the value in text.
        const n = Number(t.original.value);      
        lines.push(`    public static let ${camel(t.path.at(-1))}: CGFloat = ${n}`);
      });

    lines.push('');

    // families (force quoted string)
    dictionary.allTokens
      .filter(t=>t.type==='fontFamily')
      .forEach(t=>{
        const fn = camel(t.path.at(-1));
        lines.push(`    public static func ${fn}(size: CGFloat? = nil) -> Font {`);
        lines.push(`      return Font.custom(${JSON.stringify(t.value)}, size: size ?? body, relativeTo: .body)`);
        lines.push('    }\n');
      });

    lines.push('  }\n');

    /* ---------- Radius ------------- */
    lines.push('  enum GeneratedRadius {');
    dictionary.allTokens
      .filter(t=>t.type==='borderRadius')
      .forEach(t=>lines.push(`    public static let ${camel(t.path.at(-1))}: CGFloat = ${t.value}`));
    lines.push('  }\n');

    /* ---------- Spacing ------------ */
    lines.push('  enum GeneratedSpacing {');
    dictionary.allTokens
      .filter(t=>t.type==='spacing')
      .forEach(t=>lines.push(`    public static let ${camel(t.path.at(-1))}: CGFloat = ${t.value}`));
    lines.push('  }\n');

    /* ---------- Shadows ------------ */
    lines.push('  enum GeneratedShadows {');
    const shadows={};
    dictionary.allTokens
      .filter(t=>t.path[0]==='shadow')
      .forEach(t=>{
        const [,name,prop] = t.path;
        shadows[name] ??= {};
        shadows[name][prop] = t.value;
      });
    Object.entries(shadows).forEach(([name,p])=>{
      const alpha = +(/^rgba\(0,\s*0,\s*0,\s*([\d.]+)\)/.exec(p.color)?.[1]||0.1);
      lines.push(`    public static let ${camel(name)} = Shadow(`);
      lines.push(`      color: Color.black.opacity(${alpha}), radius: ${p.radius}, x: ${p.x}, y: ${p.y}`);
      lines.push('    )\n');
    });
    lines.push('  }\n');

    /* ---------- Border widths ------ */
    lines.push('  enum GeneratedBorderWidth {');
    dictionary.allTokens
      .filter(t=>t.type==='borderWidth')
      .forEach(t=>lines.push(`    public static let ${camel(t.path.at(-1))}: CGFloat = ${t.value}`));
    lines.push('  }\n');

    lines.push('}');                    // end extension
    return lines.join('\n');
  }
});

// Custom action to create iOS color assets
StyleDictionary.registerAction({
  name: 'ios/create_colorsets',
  do: (dictionary, platform) => {
    // Get all color tokens
    const baseColors = dictionary.allTokens.filter(token => 
      token.path[0] === 'color' && token.path[1] === 'base'
    );
    
    const semanticColors = dictionary.allTokens.filter(token => 
      token.path[0] === 'color' && token.path[1] === 'semantic'
    );
    
    const darkColors = dictionary.allTokens.filter(token => 
      token.path[0] === 'color' && token.path[1] === 'dark'
    );
    
    // Create assets directory - UPDATED PATH
    const assetsDir = path.join(__dirname, '../ios/PTDesignSystem/Sources/DesignTokens/Resources/Colors.xcassets');
    if (!fs.existsSync(assetsDir)) {
      fs.mkdirSync(assetsDir, { recursive: true });
    }
    
    // Create main Contents.json
    const contentsJson = {
      info: {
        author: 'style-dictionary',
        version: 1
      }
    };
    
    fs.writeFileSync(
      path.join(assetsDir, 'Contents.json'),
      JSON.stringify(contentsJson, null, 2)
    );
    
    // Create color sets for base colors
    baseColors.forEach(token => {
      const colorName = token.path[token.path.length - 1];
      const capitalizedName = colorName.charAt(0).toUpperCase() + 
                             colorName.slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      
      // Create color set directory
      const colorSetDir = path.join(assetsDir, `${capitalizedName}.colorset`);
      if (!fs.existsSync(colorSetDir)) {
        fs.mkdirSync(colorSetDir, { recursive: true });
      }
      
      // Find dark mode variant if exists
      let darkValue = token.value;
      
      // Look for a matching dark mode color
      const darkToken = darkColors.find(dt => {
        return dt.path[dt.path.length - 1] === colorName;
      });
      
      if (darkToken) {
        darkValue = darkToken.value;
      }
      
      // Parse color values
      let lightRgb = { r: 0, g: 0, b: 0, a: 1 };
      let darkRgb = { r: 0, g: 0, b: 0, a: 1 };
      
      // Parse colors based on format
      if (token.value.startsWith('#')) {
        lightRgb = hexToRgb(token.value);
      } else if (token.value.includes('UIColor')) {
        lightRgb = parseUIColor(token.value);
      }
      
      if (darkValue.startsWith('#')) {
        darkRgb = hexToRgb(darkValue);
      } else if (darkValue.includes('UIColor')) {
        darkRgb = parseUIColor(darkValue);
      }
      
      // Create Contents.json for the color set
      const colorContents = {
        colors: [
          {
            idiom: 'universal',
            color: {
              'color-space': 'srgb',
              components: {
                red: lightRgb.r.toFixed(3),
                green: lightRgb.g.toFixed(3),
                blue: lightRgb.b.toFixed(3),
                alpha: '1.000'
              }
            }
          },
          {
            idiom: 'universal',
            appearances: [
              {
                appearance: 'luminosity',
                value: 'dark'
              }
            ],
            color: {
              'color-space': 'srgb',
              components: {
                red: darkRgb.r.toFixed(3),
                green: darkRgb.g.toFixed(3),
                blue: darkRgb.b.toFixed(3),
                alpha: '1.000'
              }
            }
          }
        ],
        info: {
          author: 'style-dictionary',
          version: 1
        }
      };
      
      fs.writeFileSync(
        path.join(colorSetDir, 'Contents.json'),
        JSON.stringify(colorContents, null, 2)
      );
    });
    
    // Process semantic colors
    semanticColors.forEach(token => {
      let colorName;
      let colorValue;
      
      // Handle text subgroup specially
      if (token.path.includes('text')) {
        colorName = `Text${token.path[token.path.length - 1].charAt(0).toUpperCase()}${token.path[token.path.length - 1].slice(1)}`;
      } else {
        colorName = token.path[token.path.length - 1].charAt(0).toUpperCase() + 
                   token.path[token.path.length - 1].slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      }
      
      // Create color set directory
      const colorSetDir = path.join(assetsDir, `${colorName}.colorset`);
      if (!fs.existsSync(colorSetDir)) {
        fs.mkdirSync(colorSetDir, { recursive: true });
      }
      
      // Resolve the reference to base color
      colorValue = token.value;
      let alpha = token.alpha || 1.0;
      
      // If this references another color, resolve it
      if (colorValue.startsWith('{') && colorValue.endsWith('}')) {
        const referencePath = colorValue
          .substring(1, colorValue.length - 1)
          .split('.')
          .slice(0, -1); // Remove '.value' at the end
          
        const referencedToken = dictionary.tokens[referencePath[0]];
        if (referencedToken) {
          let current = referencedToken;
          for (let i = 1; i < referencePath.length; i++) {
            current = current[referencePath[i]];
            if (!current) break;
          }
          
          if (current && current.value) {
            colorValue = current.value;
          }
        }
      }
      
      // Find dark mode variant if possible
      let darkValue = colorValue;
      const darkTokenName = token.path[token.path.length - 1];
      const darkToken = darkColors.find(dt => dt.path[dt.path.length - 1] === darkTokenName);
      
      if (darkToken) {
        darkValue = darkToken.value;
        // If dark value is a reference, resolve it
        if (darkValue.startsWith('{') && darkValue.endsWith('}')) {
          const darkReferencePath = darkValue
            .substring(1, darkValue.length - 1)
            .split('.')
            .slice(0, -1); // Remove '.value' at the end
            
          const darkReferencedToken = dictionary.tokens[darkReferencePath[0]];
          if (darkReferencedToken) {
            let current = darkReferencedToken;
            for (let i = 1; i < darkReferencePath.length; i++) {
              current = current[darkReferencePath[i]];
              if (!current) break;
            }
            
            if (current && current.value) {
              darkValue = current.value;
            }
          }
        }
      }
      
      // Parse color values
      let lightRgb = { r: 0, g: 0, b: 0, a: alpha };
      let darkRgb = { r: 0, g: 0, b: 0, a: alpha };
      
      // Parse colors based on format
      if (colorValue.startsWith('#')) {
        lightRgb = hexToRgb(colorValue);
        lightRgb.a = alpha;
      } else if (colorValue.includes('UIColor')) {
        lightRgb = parseUIColor(colorValue);
        lightRgb.a = alpha;
      }
      
      if (darkValue.startsWith('#')) {
        darkRgb = hexToRgb(darkValue);
        darkRgb.a = alpha;
      } else if (darkValue.includes('UIColor')) {
        darkRgb = parseUIColor(darkValue);
        darkRgb.a = alpha;
      }
      
      // Create Contents.json for the color set
      const colorContents = {
        colors: [
          {
            idiom: 'universal',
            color: {
              'color-space': 'srgb',
              components: {
                red: lightRgb.r.toFixed(3),
                green: lightRgb.g.toFixed(3),
                blue: lightRgb.b.toFixed(3),
                alpha: lightRgb.a.toFixed(3)
              }
            }
          },
          {
            idiom: 'universal',
            appearances: [
              {
                appearance: 'luminosity',
                value: 'dark'
              }
            ],
            color: {
              'color-space': 'srgb',
              components: {
                red: darkRgb.r.toFixed(3),
                green: darkRgb.g.toFixed(3),
                blue: darkRgb.b.toFixed(3),
                alpha: darkRgb.a.toFixed(3)
              }
            }
          }
        ],
        info: {
          author: 'style-dictionary',
          version: 1
        }
      };
      
      fs.writeFileSync(
        path.join(colorSetDir, 'Contents.json'),
        JSON.stringify(colorContents, null, 2)
      );
    });
  },
  undo: () => {
    // Optional: Clean up generated files
  }
});

// Basic config - UPDATED PATHS
module.exports = {
  source: ['design-tokens.json'],
  platforms: {
    ios: {
      transformGroup: 'ios',
      buildPath: '../ios/PTDesignSystem/Sources/DesignTokens/Generated/',
      files: [
        {
          destination: 'AppTheme+Generated.swift',
          format: 'ios/swift/extension',
          className: 'AppTheme'
        }
      ],
      actions: ['ios/create_colorsets']
    },
    css: {
      transformGroup: 'css',
      buildPath: 'build/web/',
      files: [
        {
          destination: 'variables.css',
          format: 'css/variables'
        }
      ]
    },
    json: {
      transformGroup: 'js',
      buildPath: 'build/json/',
      files: [
        {
          destination: 'tokens.json',
          format: 'json/flat'
        }
      ]
    }
  }
}; 