const StyleDictionary = require('style-dictionary');
const fs = require('fs');
const path = require('path');

// Helper function to convert hex to RGB
function hexToRgb(hex) {
  // Remove # if present
  hex = hex.replace('#', '');
  
  // Convert 3-digit hex to 6-digit
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  
  // Parse hex values
  try {
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;
    
    // Validate values
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      console.error(`Invalid hex color: #${hex}`);
      return { r: 0.957, g: 0.945, b: 0.902 }; // Default cream color
    }
    
    return { r, g, b };
  } catch (error) {
    console.error(`Error parsing hex color #${hex}: ${error.message}`);
    return { r: 0.957, g: 0.945, b: 0.902 }; // Default cream color
  }
}

// Helper function to parse UIColor format
function parseUIColor(colorString) {
  // Extract RGB values from [UIColor colorWithRed:0.957f green:0.945f blue:0.902f alpha:1.000f]
  const regex = /colorWithRed:([\d\.]+)f\s+green:([\d\.]+)f\s+blue:([\d\.]+)f\s+alpha:([\d\.]+)f/;
  const match = colorString.match(regex);
  
  if (match) {
    return {
      r: parseFloat(match[1]),
      g: parseFloat(match[2]),
      b: parseFloat(match[3]),
      a: parseFloat(match[4])
    };
  }
  
  return { r: 0, g: 0, b: 0, a: 1 };
}

// Register a format for iOS Swift color extension
StyleDictionary.registerFormat({
  name: 'ios/swift/colors',
  formatter: function({ dictionary, platform }) {
    const colorTokens = dictionary.allTokens.filter(token => token.type === 'color');
    
    let output = `// Generated by Style Dictionary\nimport SwiftUI\n\npublic extension AppTheme {\n`;
    output += `  enum GeneratedColors {\n`;
    
    // Generate color constants
    colorTokens.filter(token => token.path.includes('base')).forEach(token => {
      const colorName = token.path[token.path.length - 1];
      const swiftName = colorName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      output += `    public static let ${swiftName} = Color("${colorName.charAt(0).toUpperCase() + colorName.slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase())}")\n`;
    });
    
    output += `  }\n`;
    
    // Generate typography constants
    output += `  enum GeneratedTypography {\n`;
    
    // Font sizes
    dictionary.allTokens
      .filter(token => token.path.includes('font') && token.path.includes('size'))
      .forEach(token => {
        const fontName = token.path[token.path.length - 1];
        const swiftName = fontName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
        output += `    public static let ${swiftName}: CGFloat = ${token.value}\n`;
      });
    
    // Font families
    output += '\n';
    dictionary.allTokens
      .filter(token => token.path.includes('font') && token.path.includes('family'))
      .forEach(token => {
        const fontName = token.path[token.path.length - 1];
        const swiftName = fontName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
        output += `    public static func ${swiftName}(size: CGFloat) -> Font {\n`;
        output += `      return Font.custom("${token.value}", size: size, relativeTo: .body)\n`;
        output += `    }\n\n`;
      });
    
    output += `  }\n`;
    
    // Generate radius constants
    output += `  enum GeneratedRadius {\n`;
    dictionary.allTokens.filter(token => token.path.includes('radius')).forEach(token => {
      const radiusName = token.path[token.path.length - 1];
      const swiftName = radiusName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      output += `    public static let ${swiftName}: CGFloat = ${token.value}\n`;
    });
    output += `  }\n`;
    
    // Generate spacing constants
    output += `  enum GeneratedSpacing {\n`;
    dictionary.allTokens.filter(token => token.path.includes('spacing')).forEach(token => {
      const spacingName = token.path[token.path.length - 1];
      const swiftName = spacingName.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      output += `    public static let ${swiftName}: CGFloat = ${token.value}\n`;
    });
    output += `  }\n`;
    
    // Generate shadow constants
    output += `  enum GeneratedShadows {\n`;
    const shadowGroups = {};
    
    // Group shadows by name
    dictionary.allTokens
      .filter(token => token.path.includes('shadow'))
      .forEach(token => {
        const shadowName = token.path[token.path.length - 2];
        const propertyName = token.path[token.path.length - 1];
        
        if (!shadowGroups[shadowName]) {
          shadowGroups[shadowName] = {};
        }
        
        shadowGroups[shadowName][propertyName] = token.value;
      });
    
    // Output shadow definitions
    Object.entries(shadowGroups).forEach(([name, props]) => {
      if (props.color && props.radius && props.x && props.y) {
        const swiftName = name.replace(/-([a-z])/g, (_, g) => g.toUpperCase());
        output += `    public static let ${swiftName} = Shadow(\n`;
        output += `      color: Color("${props.color}"),\n`;
        output += `      radius: ${props.radius},\n`;
        output += `      x: ${props.x},\n`;
        output += `      y: ${props.y}\n`;
        output += `    )\n\n`;
      }
    });
    
    output += `  }\n`;
    
    output += `}\n`;
    return output;
  }
});

// Register a format for CSS custom properties
StyleDictionary.registerFormat({
  name: 'css/variables',
  formatter: function({ dictionary, platform }) {
    let output = `/* Generated by Style Dictionary */\n\n:root {\n`;
    
    // Output color variables
    output += '  /* Colors */\n';
    dictionary.allTokens
      .filter(token => token.type === 'color' && token.path.includes('base'))
      .forEach(token => {
        const colorName = token.path[token.path.length - 1];
        output += `  --color-${colorName}: ${token.value};\n`;
      });
    
    // Output semantic color mappings
    output += '\n  /* Semantic Colors */\n';
    dictionary.allTokens
      .filter(token => token.type === 'color' && token.path.includes('semantic'))
      .forEach(token => {
        const path = token.path;
        if (path.includes('text')) {
          const textType = path[path.length - 1];
          output += `  --text-${textType}: var(--color-${token.original.value.replace('{color.base.', '').replace('.value}', '')});\n`;
        } else {
          const colorName = path[path.length - 1];
          output += `  --${colorName}: var(--color-${token.original.value.replace('{color.base.', '').replace('.value}', '')});\n`;
        }
      });
    
    // Output font families
    output += '\n  /* Typography */\n';
    dictionary.allTokens
      .filter(token => token.type === 'fontFamily')
      .forEach(token => {
        const fontName = token.path[token.path.length - 1];
        output += `  --font-${fontName}: "${token.value}";\n`;
      });
    
    // Output font sizes
    output += '\n  /* Font Sizes */\n';
    dictionary.allTokens
      .filter(token => token.type === 'fontSize')
      .forEach(token => {
        const sizeName = token.path[token.path.length - 1];
        output += `  --font-size-${sizeName}: ${token.value}px;\n`;
      });
    
    // Output spacing
    output += '\n  /* Spacing */\n';
    dictionary.allTokens
      .filter(token => token.type === 'spacing')
      .forEach(token => {
        const spacingName = token.path[token.path.length - 1];
        output += `  --spacing-${spacingName}: ${token.value}px;\n`;
      });
    
    // Output radius
    output += '\n  /* Border Radius */\n';
    dictionary.allTokens
      .filter(token => token.type === 'borderRadius')
      .forEach(token => {
        const radiusName = token.path[token.path.length - 1];
        output += `  --radius-${radiusName}: ${token.value}px;\n`;
      });
    
    output += `}\n\n`;
    
    // Dark mode variables
    output += `.dark {\n`;
    dictionary.allTokens
      .filter(token => token.type === 'color' && token.path.includes('dark'))
      .forEach(token => {
        const colorName = token.path[token.path.length - 1];
        if (token.original.value.includes('{color.base.')) {
          const refColor = token.original.value.replace('{color.base.', '').replace('.value}', '');
          output += `  --${colorName}: var(--color-${refColor});\n`;
        } else {
          output += `  --${colorName}: ${token.value};\n`;
        }
      });
    output += `}\n`;
    
    return output;
  }
});

// Custom action to create iOS color assets
StyleDictionary.registerAction({
  name: 'ios/create_colorsets',
  do: (dictionary, platform) => {
    const baseColors = dictionary.allTokens.filter(token => 
      token.type === 'color' && token.path.includes('base')
    );
    
    // Create assets directory
    const assetsDir = path.join(__dirname, 'build/ios/Colors.xcassets');
    if (!fs.existsSync(assetsDir)) {
      fs.mkdirSync(assetsDir, { recursive: true });
    }
    
    // Create main Contents.json
    const contentsJson = {
      info: {
        author: 'style-dictionary',
        version: 1
      }
    };
    
    fs.writeFileSync(
      path.join(assetsDir, 'Contents.json'),
      JSON.stringify(contentsJson, null, 2)
    );
    
    // Find dark mode counterparts
    const darkColors = dictionary.allTokens.filter(token => 
      token.type === 'color' && token.path.includes('dark')
    );
    
    // Create each color set
    baseColors.forEach(token => {
      const colorName = token.path[token.path.length - 1];
      const capitalizedName = colorName.charAt(0).toUpperCase() + 
                             colorName.slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      
      // Create color set directory
      const colorSetDir = path.join(assetsDir, `${capitalizedName}.colorset`);
      if (!fs.existsSync(colorSetDir)) {
        fs.mkdirSync(colorSetDir, { recursive: true });
      }
      
      // Find dark mode variant (if exists)
      let darkValue = token.value;
      
      // Look for a matching dark mode color
      const darkToken = darkColors.find(dt => {
        // Check if this dark token is the same as the current token's name
        return dt.path[dt.path.length - 1] === colorName;
      });
      
      if (darkToken) {
        darkValue = darkToken.value;
      }
      
      // Parse color values
      let lightRgb = { r: 0, g: 0, b: 0, a: 1 };
      let darkRgb = { r: 0, g: 0, b: 0, a: 1 };
      
      // Parse colors based on format
      if (token.value.startsWith('#')) {
        console.log(`Processing hex color ${colorName} with value ${token.value}`);
        lightRgb = hexToRgb(token.value);
      } else if (token.value.includes('UIColor')) {
        console.log(`Processing UIColor ${colorName}: ${token.value}`);
        lightRgb = parseUIColor(token.value);
      } else {
        console.log(`Unknown color format for ${colorName}: ${token.value}`);
      }
      
      if (darkValue.startsWith('#')) {
        console.log(`Processing dark hex color for ${colorName}: ${darkValue}`);
        darkRgb = hexToRgb(darkValue);
      } else if (darkValue.includes('UIColor')) {
        console.log(`Processing dark UIColor for ${colorName}: ${darkValue}`);
        darkRgb = parseUIColor(darkValue);
      } else {
        console.log(`Unknown dark color format for ${colorName}: ${darkValue}`);
      }
      
      // Create Contents.json for the color set
      const colorContents = {
        colors: [
          {
            idiom: 'universal',
            color: {
              'color-space': 'srgb',
              components: {
                red: lightRgb.r.toFixed(3),
                green: lightRgb.g.toFixed(3),
                blue: lightRgb.b.toFixed(3),
                alpha: '1.000'
              }
            }
          },
          {
            idiom: 'universal',
            appearances: [
              {
                appearance: 'luminosity',
                value: 'dark'
              }
            ],
            color: {
              'color-space': 'srgb',
              components: {
                red: darkRgb.r.toFixed(3),
                green: darkRgb.g.toFixed(3),
                blue: darkRgb.b.toFixed(3),
                alpha: '1.000'
              }
            }
          }
        ],
        info: {
          author: 'style-dictionary',
          version: 1
        }
      };
      
      fs.writeFileSync(
        path.join(colorSetDir, 'Contents.json'),
        JSON.stringify(colorContents, null, 2)
      );
    });
    
    // Also create semantic colors
    const semanticColors = dictionary.allTokens.filter(token => 
      token.type === 'color' && token.path.includes('semantic')
    );
    
    // Process each semantic color
    semanticColors.forEach(token => {
      let colorName;
      if (token.path.includes('text')) {
        colorName = `Text${token.path[token.path.length - 1].charAt(0).toUpperCase()}${token.path[token.path.length - 1].slice(1)}`;
      } else {
        colorName = token.path[token.path.length - 1].charAt(0).toUpperCase() + 
                  token.path[token.path.length - 1].slice(1).replace(/-([a-z])/g, (_, g) => g.toUpperCase());
      }
      
      // Create color set directory
      const colorSetDir = path.join(assetsDir, `${colorName}.colorset`);
      if (!fs.existsSync(colorSetDir)) {
        fs.mkdirSync(colorSetDir, { recursive: true });
      }
      
      // Find the base color value
      let baseColorValue = token.value;
      if (token.original.value.startsWith('{color.base.')) {
        const baseColorName = token.original.value.replace('{color.base.', '').replace('.value}', '');
        const baseColorToken = baseColors.find(bc => bc.path[bc.path.length - 1] === baseColorName);
        if (baseColorToken) {
          baseColorValue = baseColorToken.value;
        }
      }
      
      // Find dark mode variant if possible
      let darkValue = baseColorValue;
      const darkTokenName = token.path[token.path.length - 1];
      const darkToken = darkColors.find(dt => dt.path[dt.path.length - 1] === darkTokenName);
      if (darkToken) {
        darkValue = darkToken.value;
        if (darkToken.original.value.startsWith('{color.base.')) {
          const darkBaseColorName = darkToken.original.value.replace('{color.base.', '').replace('.value}', '');
          const darkBaseToken = baseColors.find(bc => bc.path[bc.path.length - 1] === darkBaseColorName);
          if (darkBaseToken) {
            darkValue = darkBaseToken.value;
          }
        }
      }
      
      // Parse color values
      let lightRgb = { r: 0, g: 0, b: 0, a: 1 };
      let darkRgb = { r: 0, g: 0, b: 0, a: 1 };
      
      // Parse colors based on format
      if (baseColorValue.startsWith('#')) {
        console.log(`Processing hex color ${colorName} with value ${baseColorValue}`);
        lightRgb = hexToRgb(baseColorValue);
      } else if (baseColorValue.includes('UIColor')) {
        console.log(`Processing UIColor ${colorName}: ${baseColorValue}`);
        lightRgb = parseUIColor(baseColorValue);
      } else {
        console.log(`Unknown color format for ${colorName}: ${baseColorValue}`);
      }
      
      if (darkValue.startsWith('#')) {
        console.log(`Processing dark hex color for ${colorName}: ${darkValue}`);
        darkRgb = hexToRgb(darkValue);
      } else if (darkValue.includes('UIColor')) {
        console.log(`Processing dark UIColor for ${colorName}: ${darkValue}`);
        darkRgb = parseUIColor(darkValue);
      } else {
        console.log(`Unknown dark color format for ${colorName}: ${darkValue}`);
      }
      
      // Create Contents.json for the color set
      const colorContents = {
        colors: [
          {
            idiom: 'universal',
            color: {
              'color-space': 'srgb',
              components: {
                red: lightRgb.r.toFixed(3),
                green: lightRgb.g.toFixed(3),
                blue: lightRgb.b.toFixed(3),
                alpha: '1.000'
              }
            }
          },
          {
            idiom: 'universal',
            appearances: [
              {
                appearance: 'luminosity',
                value: 'dark'
              }
            ],
            color: {
              'color-space': 'srgb',
              components: {
                red: darkRgb.r.toFixed(3),
                green: darkRgb.g.toFixed(3),
                blue: darkRgb.b.toFixed(3),
                alpha: '1.000'
              }
            }
          }
        ],
        info: {
          author: 'style-dictionary',
          version: 1
        }
      };
      
      fs.writeFileSync(
        path.join(colorSetDir, 'Contents.json'),
        JSON.stringify(colorContents, null, 2)
      );
    });
  },
  undo: () => {
    // Optional: Clean up generated files
  }
});

// Basic config
module.exports = {
  source: ['design-tokens.json'],
  platforms: {
    ios: {
      transformGroup: 'ios',
      buildPath: 'build/ios/',
      files: [
        {
          destination: 'AppTheme+Generated.swift',
          format: 'ios/swift/colors'
        }
      ],
      actions: ['ios/create_colorsets']
    },
    css: {
      transformGroup: 'css',
      buildPath: 'build/web/',
      files: [
        {
          destination: 'variables.css',
          format: 'css/variables'
        }
      ]
    },
    json: {
      transformGroup: 'js',
      buildPath: 'build/json/',
      files: [
        {
          destination: 'tokens.json',
          format: 'json/flat'
        }
      ]
    }
  }
}; 